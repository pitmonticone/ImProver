<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AlphaProof Experiment - Proof Optimization Project</title>
  <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.4.0/css/pico.min.css">
  <link rel="stylesheet" href="../assets/css/style.css">
  <script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
  <main class="container">
    <header>
      <nav>
        <ul>
          <li><strong>ImProof</strong></li>
          <li><a href="../index.html">Home</a></li>
          <li><a href="../overview.html">Overview</a></li>
          <li><a href="../experiments.html">Results</a></li>
          <li><a href="../team.html">Team</a></li>
          <!-- <li><a href="https://github.com/riyazahuja/Automated-Proof-Rewriting">Code</a></li> -->
        </ul>
      </nav>
    </header>
    <article>
      <header>
        <h1>AlphaProof Optimization</h1>
        <p>Improving the readability and modularity of AlphaProof's IMO 2024 results.</p>
      </header>
      <section>
        <h2>Overview</h2>
        <p>The <a href="https://deepmind.google/discover/blog/ai-solves-imo-problems-at-silver-medal-level/">AlphaProof model</a>, developed by <a href="https://deepmind.google/">Google DeepMind</a>, achieved impressive results on the 2024 IMO.</p>
        <p>The IMO, widely considered to be the most prestigious and difficult mathematics competiton for pre-collegiate mathematicians, is split into 6 problems ranging between algebra, combinatorics, geometry, and number theory.
          Over the span of three days, AlphaProof was able to solve 4 of 6 problems, with the geometry solution being generated by the adjacent AlphaGeometry2 model. This is equivalent to a silver medal, ignoring the 9 hour time limit split between two sessions for human participants.
        <p>AlphaProof relies on human-formalized theorem statements in the Lean 4 interactive theorem proving language, outputting formal theorems in the same language. As AlphaGeometry2 is a hybrid neurosymbolic model that does not use Lean 4, we do not explore the geometry question and rather focus on the remaining algebra, combinatorics, and number theory questions that were correctly solved.</p>
        <p>Despite these SoTA results by DeepMind, <a href="https://leanprover.zulipchat.com/#narrow/stream/219941-Machine-Learning-for-Theorem-Proving/topic/IMO.20results.20from.20Google.20DeepMind/near/453998516">mathematicians have been vocal on the quality of the generated proofs</a>. Formal proofs are notorious for their opacity and lack of clarity in a traditional theorem-proving sense. This lack of readability or modularity in the generated proofs results in a weakened ability for pedagogical value to be derived from these results, let alone interpreting the results in any intuitive way.</p>
        <p>Our tool optimized these these proofs, significantly improving their readability and structure.</p>
        <p>You can download the original proofs and improved proofs <a href="../assets/experiments/alphaproof/data.zip">here</a>. Or keep reading to see our improved proofs and analysis.</p>
      </section>
      <section>
        <h2>Results</h2>
        <details>
          <summary>Problem 1</summary>
          <p><strong>Problem:</strong> Determine all real numbers \(\alpha\) such that, for every positive integer \(n\), the integer
            \[
            \lfloor \alpha\rfloor + \lfloor2\alpha\rfloor + \cdots + \lfloor n\alpha\rfloor
            \]
            is a multiple of \(n\).
            (Note that \(\lfloor z\rfloor\) denotes the greatest integer less than or equal to \(z\).
            For example, \(\lfloor-\pi\rfloor = -4\) and \(\lfloor2\rfloor = \lfloor2.9\rfloor = 2\).)
          <p><strong>Solution:</strong> \(\alpha\) is an even integer.</p>
            
          <div class="columns">
            <pre><code>
theorem imo_2024_p1 :
{(α : ℝ) | ∀ (n : ℕ), 0 < n → (n : ℤ) ∣ (∑ i in Finset.Icc 1 n, ⌊i * α⌋)}
= {α : ℝ | ∃ k : ℤ, Even k ∧ α = k} := by
rw [(Set.Subset.antisymm_iff ), (Set.subset_def), ]
/- We introduce a variable that will be used
  in the second part of the proof (the hard direction),
  namely the integer `l` such that `2l = ⌊α⌋ + ⌊2α⌋`
  (this comes from the given divisibility condition with `n = 2`). -/
existsλx L=>(L 2 two_pos).rec λl Y=>?_
useλy . x=>y.rec λS p=>?_
· /- We start by showing that every `α` of the form `2k` works.
    In this case, the sum simplifies to `kn(n+1)`),
    which is clearly divisible by `n`. -/
  simp_all[λL:ℕ=>(by norm_num[Int.floor_eq_iff]:⌊(L:ℝ)*S⌋=L* S )]
  rw[p.2,Int.dvd_iff_emod_eq_zero,Nat.lt_iff_add_one_le,<-Finset.sum_mul,←Nat.cast_sum, S.even_iff, ←Nat.Ico_succ_right,@ .((( Finset.sum_Ico_eq_sum_range))),Finset.sum_add_distrib ]at*
  simp_all[Finset.sum_range_id]
  exact dvd_trans ⟨2+((_:ℕ)-1),by linarith[((‹ℕ›:Int)*(‹Nat›-1)).ediv_mul_cancel$ Int.prime_two.dvd_mul.2<|by ·omega]⟩ ↑↑(mul_dvd_mul_left @_ (p))
/- Now let's prove the converse, i.e. that every `α` in the LHS
  is an even integer. We claim for all such `α` and `n ∈ ℕ`, we have
  `⌊(n+1)*α⌋ = ⌊α⌋+2n(l-⌊α⌋)`. -/
suffices : ∀ (n : ℕ),⌊(n+1)*x⌋ =⌊ x⌋+2 * ↑ (n : ℕ) * (l-(⌊(x)⌋))
· /- Let's assume for now that the claim is true,
    and see how this is enough to finish our proof. -/
  zify[mul_comm,Int.floor_eq_iff] at this
  -- We'll show that `α = 2(l-⌊α⌋)`, which is obviously even.
  use(l-⌊x⌋)*2
  norm_num
  -- To do so, it suffices to show `α ≤ 2(l-⌊α⌋)` and `α ≥ 2(l-⌊α⌋)`.
  apply@le_antisymm
  /- To prove the first inequality, notice that if `α > 2(l-⌊α⌋)` then
    there exists an integer `N > 0` such that `N ≥ 1/(α - 2(l -⌊α⌋))`.
    By our assumed claim (with `n = N`), we have
    `⌊α⌋ + 2(l-⌊α⌋)N + 1 > (N+1)α`, i.e.
    `⌊α⌋ + (2(l-⌊α⌋) - α)N + 1 > α`,
    and this implies `⌊α⌋ > α`; contradiction. -/
  use not_lt.1 (by cases exists_nat_ge (1/(x-_)) with|_ N =>nlinarith[ one_div_mul_cancel $ sub_ne_zero.2 ·.ne',9,Int.floor_le x, this N])
/- Similarly, if `α < 2(l-⌊α⌋)` then we can find a positive natural `N`
    such that `N ≥ 1/(2(l-⌊α⌋) - α)`.
    By our claim (with `n = N`), we have
    `(N+1)α ≥ ⌊α⌋ + 2(l-⌊α⌋)N`, i.e.
    `α ≥ ⌊α⌋ + (2(l-⌊α⌋) - α)N`,
    and this implies `a ≥ ⌊α⌋ + 1`; contradiction. -/
  use not_lt.1 (by cases exists_nat_ge (1/_:ℝ)with|_ A=>nlinarith[Int.lt_floor_add_one x,one_div_mul_cancel$ sub_ne_zero.2 ·.ne',this A])
/- Now all that's left to do is to prove our claim
  `⌊(n + 1)α⌋ = ⌊α⌋ + 2n(l - ⌊α⌋)`. -/
intro
-- We argue by strong induction on `n`.
induction‹_› using@Nat.strongInductionOn
-- By our hypothesis on `α`, we know that `(n+1) | ∑_{i=1}^(n+1) ⌊iα⌋`
specialize L$ ‹_›+1
simp_all[add_comm,mul_assoc,Int.floor_eq_iff,<-Nat.Ico_succ_right, add_mul,(Finset.range_succ), Finset.sum_Ico_eq_sum_range]
revert‹ℕ›
/- Thus, there exists `c` such that
  `(n+1)*c = ∑_{i=1}^{n+1} ⌊iα⌋ = ⌊nα+α⌋ + ∑_{i=1}^n ⌊iα⌋`. -/
rintro A B@c
simp_all[ Finset.mem_range.mp _,←eq_sub_iff_add_eq',Int.floor_eq_iff]
/- By the inductive hypothesis,
  `∑_{i=0}^{n-1}, ⌊α+iα⌋ = ∑_{i=0}^{n-1}, ⌊α⌋+2*i*(l-⌊α⌋)`. -/
suffices:∑d in .range A,⌊x+d*x⌋=∑Q in .range A,(⌊x⌋+2*(Q * (l-.floor x)))
· suffices:∑d in ( .range A),(((d)):ℤ) =A * ( A-1)/2
  · have:(A : ℤ) * (A-1)%2=0
    · cases@Int.emod_two_eq A with|_ B=>norm_num[B,Int.sub_emod,Int.mul_emod]
    norm_num at*
    norm_num[ Finset.sum_add_distrib,<-Finset.sum_mul, ←Finset.mul_sum _ _] at*
    rw[eq_sub_iff_add_eq]at*
    /- Combined with
      `∑_{i=0}^{n-1},⌊iα+α⌋ = (n+1)c - ⌊nα+α⌋`,
      we have `⌊nα+α⌋ = (n+1)c - n⌊α⌋ - n(n-1)(l-⌊α⌋)`, so
      `⌊nα+α⌋ ≥ (n+1)c - n⌊α⌋ - n(n-1)(l-⌊α⌋)`
      and
      `⌊nα+α⌋ < (n+1)c - n⌊α⌋ - n(n-1)(l-⌊α⌋) + 1`.
      Also, since `2*l = ⌊α⌋ + ⌊2α⌋`, we have
      `2α+⌊α⌋-1 < 2*l ≤ 2α+⌊α⌋.`-/
    zify[←mul_assoc, this,←eq_sub_iff_add_eq',‹_ =(@ _) /@_›,Int.floor_eq_iff] at *
    zify[*]at*
    -- We will now show that `c = n*(l-⌊α⌋) + ⌊α⌋`.
    cases S5:lt_or_ge c (A * (l-.floor ↑x)+⌊x⌋ + 1)
    · simp_all
      have:(c+1:ℝ)<=A*(l-⌊x⌋)+⌊x⌋+1:=by norm_cast
      simp_all
      cases this.eq_or_lt
      · /- For if `c = n*(l-⌊α⌋) + ⌊α⌋`, then
          ```
          ⌊(n+1)α⌋ = (n+1)c - n⌊α⌋ - n(n-1)(l-⌊α⌋)
          = (n+1)(n(l - ⌊α⌋) + ⌊α⌋) - n⌊α⌋ - n(n-1)(l-⌊α⌋)
          = 2n(l-⌊α⌋) + ⌊α⌋
          ```
          as desired. -/
        repeat use by nlinarith
      /- Now, we show `c = n*(l-⌊α⌋) + ⌊α⌋` via contradiction
        split into two cases. First suppose `c ≤ n(l - ⌊α⌋) + ⌊α⌋ - 1`.
        ```
        (n+1)α < (n+1)c - n⌊α⌋ - n(n-1)(l-⌊α⌋) + 1
        ≤ (n+1)(n(l-⌊α⌋) + ⌊α⌋ - 1) - n⌊α⌋ - n(n-1)(l-⌊α⌋) + 1
        = 2n(l-⌊α⌋) + ⌊α⌋ - n
        = 2ln - 2n⌊α⌋ + ⌊α⌋ - n
        ≤ (2α+⌊α⌋)n - 2n⌊α⌋ + ⌊α⌋ - n
        = nα + n(α-⌊α⌋-1) + ⌊α⌋
        n + α.
        ```
        contradiction. -/
      nlinarith[(by norm_cast at* :(A*(l -⌊x⌋):ℝ)+⌊(x)⌋ >=(c)+01),9,Int.add_emod ↑5,Int.floor_le (@x : ℝ),Int.lt_floor_add_one (x:)]
    /- Next, suppose `c ≥ n(l - ⌊α⌋) + ⌊α⌋ + 1`.
      ```
      (n+1)α ≥ (n+1)c - n⌊α⌋ - n(n-1)(l-⌊α⌋)
      ≥ (n+1)(n(l-⌊α⌋) + ⌊α⌋ + 1) - n⌊α⌋ - n(n-1)(l-⌊α⌋)
      = 2n(l-⌊α⌋) + ⌊α⌋ + n + 1
      = 2ln - 2n⌊α⌋ + ⌊α⌋ + n + 1
      > (2α+⌊α⌋-1)n - 2n⌊α⌋ + ⌊α⌋ + n + 1
      = nα + n(α-⌊α⌋) + ⌊α⌋ + 1
      > n + α
      ```
      contradiction. -/
    simp_all
    nlinarith[(by norm_cast:(c:ℝ)>=A*(l-⌊_⌋)+⌊_⌋+1),Int.floor_le x,Int.lt_floor_add_one x]
  rw [←Nat.cast_sum, mul_sub, Finset.sum_range_id]
  cases A with|_=>norm_num[mul_add]
use Finset.sum_congr rfl<|by simp_all[add_comm,Int.floor_eq_iff]
            </code></pre> 
            
            <pre><code>
theorem imo_2024_p1 :
  {(α : ℝ) | ∀ (n : ℕ), 0 < n → (n : ℤ) ∣ (∑ i in Finset.Icc 1 n, ⌊i * α⌋)}
  = {α : ℝ | ∃ k : ℤ, Even k ∧ α = k} := by
  ext α
  constructor
  -- Prove that every α in the left-hand side is an even integer.
  . intro h
    -- Consider n = 2 to derive a property of α.
    specialize h 2 (by norm_num)
    rw [Finset.sum_Icc, Nat.cast_two, add_zero] at h
    rcases h with ⟨l, hl⟩
    have key : ∀ n : ℕ, ⌊(n + 1) * α⌋ = ⌊α⌋ + 2 * n * (l - ⌊α⌋) := by
    . intro n
      induction n with n ih
      . simp [Nat.zero_add, mul_zero, add_zero]
      . specialize h (n + 1) (Nat.succ_pos n)
        rw [Finset.sum_Icc, Nat.cast_succ, add_zero] at h
        rcases h with ⟨k, hk⟩
        rw [ih, Nat.cast_add, mul_add, add_assoc, add_assoc, ← add_assoc l, ← add_assoc (⌊α⌋), ← add_assoc (⌊α⌋), ← hk]
        simp
    -- Using the key property to show α is even.
    have α_is_even : ∃ k : ℤ, α = 2 * k := by
      use (l - ⌊α⌋)
      norm_cast
      specialize key 1
      rw [Nat.cast_one, one_mul, add_zero] at key
      exact le_antisymm (not_lt.1 (by nlinarith)) (not_lt.1 (by nlinarith))
    exact ⟨l - ⌊α⌋, ⟨Even.intro rfl⟩, α_is_even⟩
  -- Prove that every even integer α is in the left-hand side.
  . rintro ⟨k, ⟨even_k, rfl⟩⟩
    intro n hn
    rw [Finset.sum_Icc, Nat.cast_add, add_zero]
    simp only [Int.floor_mul, Nat.cast_sum]
    have : ∑ i in Finset.Icc 1 n, (i : ℝ) * k = k * ∑ i in Finset.Icc 1 n, (i : ℝ) := by
      rw [Finset.sum_mul, mul_comm]
    rw [this, Finset.sum_Icc_eq_sum_range, Finset.sum_range_id]
    exact dvd_trans (dvd_mul_right k (n * (n + 1) / 2)) (by norm_cast; exact Int.dvd_nat_abs.mpr (Nat.two_dvd_mul_add_one_self _ _))
            </code></pre> 
          </div>
          <div class="columns">
            <p><small><i>Original</i></small></p>
            
            
            <p><small><i>ImProof</i></small>
          </div>

          <p><strong>Analysis:</strong> Do some analysis.</p>
        </details>
        <details>
          <summary>Problem 2</summary>
          <p><strong>Problem:</strong> Determine all pairs \((a, b)\) of positive integers for which there exist positive integers \(g\) and \(N\) such that
            \[\operatorname{gcd}(a^n + b, b^n + a) = g\]
            holds for all integers \(n \ge N\).
            (Note that \(\operatorname{gcd}(x, y)\) denotes the greatest common divisor of integers \(x\) and \(y\).)
          <p><strong>Solution:</strong> \(a = 1\) and \(b = 1\)</p>
            
          <div class="columns">
            <pre><code>
theorem imo_2024_p2 : {(a, b) | 0 < a ∧ 0 < b ∧ ∃ g N, 0 < g ∧ 0 < N ∧ ∀ n ≥ N, Nat.gcd (a ^ n + b) (b ^ n + a) = g} = {(1, 1)} := by
induction(10)+2
· use Set.eq_singleton_iff_unique_mem.2 ⟨?_,λb g=>by_contra$ g.2.2.rec λY S i=>S.rec λL D=>?_⟩
  · -- (1, 1) satisfies the condition with g = 2, N = 3.
    exact⟨by left,by left,2,3,by simp_all⟩
  -- We claim that this is the only solution.
  -- The agent wastes the next 16 lines proving then discarding a lemma.
  have:b.1+b.2∣Y:=?_
  · suffices: b.1= b.2
    · norm_num[b.ext_iff,<-D.2.2 L,this]at*
      use(pow_lt_pow (g.1.nat_succ_le.lt_of_ne' i) (by left)).ne' (D.2.2 _ L.le_succ)
    suffices:b.1+b.2∣b.fst^ (2 *L) +b.2 ∧(b).fst +(b).snd ∣ b.snd^ (2 *L)+b.1
    · suffices:b.1^2%(b.1+b.2)=b.2^2%(b.1+b.snd)
      · norm_num[Nat.add_mod,pow_mul,this,Nat.dvd_iff_mod_eq_zero,Nat.pow_mod]at*
        norm_num[add_comm,b.ext_iff,sq _,←Nat.pow_mod,←Nat.dvd_iff_mod_eq_zero]at*
        zify at*
        cases this.1.sub this.2with|_ Z=> nlinarith [ (by (nlinarith): Z=0 )]
      apply@Nat.modEq_of_dvd
      use(b.snd)-b.fst , (by·ring: ( (b.snd) : ℤ)^2-b.fst^2=(b.fst+(b).2) * _)
    norm_num[(2).le_mul_of_pos_left,Nat.gcd_dvd,← D.2.2 (2 *L), this.trans, (D.right.1 :_)]
  suffices:b.1+b.2∣b.1^(2*L)+b.2 ∧b.1+b.2 ∣b.snd^ (2 *L) +b.1
  · exact D.2.2 (2 *(L )) (le_mul_of_one_le_left' (by decide ) )▸dvd_gcd (this.left) (this).2
  exfalso
  -- First, assume ab + 1 | g.
  suffices:b.1*b.2+1∣Y
  · suffices:b.1^φ (b.1*b.2+1)%(b.1*b.2+1)=1%(b.1*b.2+1) ∧b.2^ φ (b.1* b.snd+1)%((b).1 * ↑(b.snd)+1)= 1% (b.1*b.snd + 1)
    · /- Then ab + 1 | a ^ (Nφ(ab + 1)) + b and
        ab + 1 | b ^ (Nφ(ab + 1)) + a. -/
      absurd D.2.2 (φ (b.1*b.2+1)*L) (by nlinarith [((b.fst *b.2+1).totient_pos).2 ↑ Fin.size_pos'])
      apply mt (.▸Nat.gcd_dvd _ _)
      useλH=>absurd (‹_∣Y›.trans H.1) (λv=>absurd (‹_∣Y›.trans H.2) ? _)
      norm_num[pow_mul,b.ext_iff,(1).mod_eq_of_lt,g.symm,this,Nat.add_mod,Nat.dvd_iff_mod_eq_zero,Nat.pow_mod]at(i)v⊢
      /- By Euler's Theorem, a ^ (Nφ(ab + 1)) ≡ 1 (mod ab + 1),
        so ab + 1 | b + 1 and ab + 1 | a + 1. -/
      norm_num[add_comm,pow_mul,<-Nat.dvd_iff_mod_eq_zero]at*
      contrapose! i
      zify at*
      /- Thus ab + 1 ≤ b + 1 and ab + 1 ≤ a + 1 which requires
        a = b = 1 as desired. -/
      repeat use by nlinarith[Int.le_of_dvd (by linarith) v,Int.le_of_dvd (by linarith) i]
    repeat use↑(Nat.ModEq.pow_totient (by norm_num))
  -- Now, we proceed to show that indeed ab + 1 | g.
  by_contra! H
  suffices:b.1^φ (b.1*b.2+1)%(b.1*b.2+1)=1%(b.1*b.2+1) ∧b.2^φ (b.1*b.2+1)%(b.1*b.2+1)=1%( b.fst * ↑ (b.snd)+1)
  · simp_all
    /- It suffices to show that
      ab + 1 | a^(φ(ab + 1)(N + 1) - 1) + b and
      ab + 1 | b^(φ(ab + 1)(N + 1) - 1) + a. -/
    suffices:b.1*b.2+1∣b.1^(φ (b.1*b.2+1)*(L+1)-1)+b.2 ∧b.1*b.2+1∣b.2^(φ (b.1* b.2+1)* (L+1)-1)+(b.fst)
    · use H$ D.2.2 (φ _ *(L+1)-1) (L.le_sub_of_add_le (by nlinarith[((b.1* b.2+1).totient_pos).2 Nat.succ_pos']))▸(((Nat.dvd_gcd) ( this).1)) this.right
    cases B:Nat.exists_eq_add_of_lt$ ((b.1*b.2+1).totient_pos).2 (by continuity)
    norm_num[*, g, ‹φ _ = _›, mul_add,Nat.pow_mod,(1).mod_eq_of_lt,pow_add,Nat.add_mod,pow_mul,Nat.dvd_iff_mod_eq_zero,Nat.mul_mod] at this⊢
    simp_all
    /- Since a, b are coprime to ab + 1, it suffices to show that
      ab + 1 | a(a^(φ(ab + 1)(N + 1) - 1) + b) and
      ab + 1 | b(b^(φ(ab + 1)(N + 1) - 1) + a). -/
    suffices:b.1*b.2+1∣b.1*( (b.1%((b).1 * ( b.snd) + 1) : _)^‹Nat› +b.snd) ∧(b.fst * ↑(b.snd) + 1)∣(b).snd*( (b.snd%((b).fst * b.snd + 1))^ ‹Nat›+b.fst)
    · norm_num[<-Nat.dvd_iff_mod_eq_zero,g,(1).mod_eq_of_lt,Nat.dvd_mul] at this⊢
      exists@?_
      · cases this.1 with|_ Q r=>simp_all[(Q.dvd_gcd r.1 ⟨_,.symm r.right.choose_spec.2⟩).antisymm]
      cases@this.2with|_ F X=>simp_all[(F.dvd_gcd X.1 ⟨_,symm X.2.choose_spec.2⟩).antisymm]
    /- This follows from Euler's Theorem:
      a(a^(φ(ab + 1)(N + 1) - 1) + b)
      ≡ a^(φ(ab + 1)(N + 1)) + ab
      ≡ 1 + ab
      ≡ 0 (mod ab + 1)
      and similarly for b(b^(φ(ab + 1)(N + 1) - 1) + a). -/
    simp_all[mul_comm, mul_add,add_comm,Nat.add_mod,Nat.dvd_iff_mod_eq_zero]
  repeat use(Nat.ModEq.pow_totient (by . . .norm_num) )
congr 26
            </code></pre> 
            
            <pre><code>
theorem imo_2024_p2 : {(a, b) | 0 < a ∧ 0 < b ∧ ∃ g N, 0 < g ∧ 0 < N ∧ ∀ n ≥ N, Nat.gcd (a ^ n + b) (b ^ n + a) = g} = {(1, 1)} := by
  ext ⟨a, b⟩
  constructor
  · rintro ⟨ha, hb, g, N, hg, hN⟩
    by_cases h : a = b
    · subst h; exact ⟨by simp [Nat.gcd_self], by simp [Nat.gcd_self]⟩
    have h1 : Nat.gcd (a ^ N + b) (b ^ N + a) = g := hN N (le_refl N)
    have h2 : Nat.gcd (a ^ (N + 1) + b) (b ^ (N + 1) + a) = g := hN (N + 1) (Nat.le_succ N)
    rw [Nat.gcd_rec (a ^ N + b) (b ^ N + a)] at h1
    rw [Nat.gcd_rec (a ^ (N + 1) + b) (b ^ (N + 1) + a)] at h2
    have : a = 1 ∧ b = 1 := by
      simp only [Nat.gcd_self, Nat.gcd_comm] at h1 h2
      exact ⟨by linarith, by linarith⟩
    exact this
  · rintro ⟨rfl, rfl⟩
    use 1, 1, 1, 1
    simp
            </code></pre> 
          </div>
          <div class="columns">
            <p><small><i>Original</i></small></p>
            
            
            <p><small><i>ImProof</i></small>
          </div>

          <p><strong>Analysis:</strong> Do some analysis.</p>
        </details>
        <details>
          <summary>Problem 6</summary>
          <p><strong>Problem:</strong> Let \(\mathbb{Q}\) be the set of rational numbers. A function \(f : \mathbb{Q} \to \mathbb{Q}\) is called <i>aquaesulian</i> if
            the following property holds: for every \(x, y \in \mathbb{Q}\),
            \[f(x + f(y)) = f(x) + y \qquad\text{or}\qquad f(f(x) + y) = x + f(y)\]
            Show that there exists an integer \(c\) such that for any aquaesulian function \(f\) there are at most
            \(c\) different rational numbers of the form \(f(r) + f(-r)\) for some rational number \(r\), and find the
            smallest possible value of \(c\).
          <p><strong>Solution:</strong> \(c = 2\)</p>
            
          <div class="columns">
            <pre><code>
theorem imo_2024_p6
    (IsAquaesulian : (ℚ → ℚ) → Prop)
    (IsAquaesulian_def : ∀ f, IsAquaesulian f ↔
      ∀ x y, f (x + f y) = f x + y ∨ f (f x + y) = x + f y) :
    IsLeast {(c : ℤ) | ∀ f, IsAquaesulian f → {(f r + f (-r)) | (r : ℚ)}.Finite ∧
      {(f r + f (-r)) | (r : ℚ)}.ncard ≤ c} 2 := by
  exists@?_
  · /- Let f be an aquaesulian function with f(0) = 0.
        We claim that f(x) + f(-x) takes on at most two distinct values. -/
    useλu b=>if j:u 0=0then by_contra λc=>?_ else ?_
    · -- If f(x) + f(-x) = 0 for all x, we are done.
      suffices:({J|∃k,u k+u (-k)= J}) ⊆{0}
      · simp_all[this.antisymm]
      -- Otherwise, take a, k such that f(a) + f(-a) = k ≠ 0.
      rintro - ⟨a, rfl⟩
      contrapose! c
      simp_all
      -- If we can show that f(x) + f(-x) = 0 or k for all x, then we are done.
      suffices:{U|∃examples6, (u) ‹ℚ› +u ( -‹_›)= U} ⊆{0,(u (a : Rat)+ (u<|@@↑(( (-a ))))) } ..
      · use ( Set.toFinite ( _) ).subset ↑@@this , (Set.ncard_le_ncard$ (((this )) ) ).trans (Set.ncard_pair$ Ne.symm (↑ ( (c)) ) ).le
      -- We now proceed to show that f(x) + f(-x) = 0 or k for all x.
      rintro-⟨hz, rfl⟩
      -- We have f(x + f(a)) = f(x) + a or f(f(x) + a) = x + f(a).
      induction b @hz a
      · -- Step "f.": First, consider the case where f(x + f(a)) = f(x) + a.
        /- Step "i.": We have f(-a + f(x + f(a))) = f(-a) + (x + f(a))
            or f(f(-a) + (x + f(a))) = -a + f(x + f(a)). -/
        have:=b (-a)$ hz+u a
        /- Step "ii.": We have f(x + f(x)) = f(x) + x or f(f(x) + x) = x + f(x).
            This simplifies to just f(x + f(x)) = x + f(x).
        -/
        have:=b hz hz
        /- Step "iii.": Substituting step “f.” into step “i.” and simplifying
            gives f(f(x)) = x + f(a) + f(-a) or f(x + f(a) + f(-a)) = f(x). -/
        simp_all[add_comm]
        /- Step "iiii.": We have f(-x + f(x + f(x))) = f(-x) + x + f(x) or
            f(f(-x) + x + f(x)) = -x + f(x + f(x)). -/
        have:=b (-hz) (hz+u ↑(hz))
        /- Substituting step “ii.” into step “iv.”, we have
            f(f(x)) = x + f(-x) + f(x) or f(x + f(-x) + f(x)) = f(x). -/
        simp_all[ add_assoc, C]
        induction this
        · -- Step "vi.": First, consider the case where f(f(x)) = x + f(-x) + f(x).
          /- Step "vi.1" In this case, step “iii.” simplifies to
              f(-x) + f(x) = f(a) + f(-a)
              or f(x + f(a) + f(-a)) = f(x). In the first case we are done,
              so we focus only on the second case. -/
          simp_all
          /- Step "vi.2": We have
              f(x + f(x + f(a) + f(-a))) = f(x) + x + (f(a) + f(-a)) or
              f(f(x) + x + f(a) + f(-a)) = x + f(x + f(a) + f(-a)). -/
          have:=b hz (hz+(u a+u (-a)))
          /- Step "vi.3": We have
              f(x + f(a) + f(-a) + f(x + f(a) + f(-a)))
              = x + f(a) + f(-a) + f(x + f(a) + f(-a)). -/
          have:=b (hz+(u a+u (-a)))$ hz+(u a+u (-a))
          /- Step "vi.4": Substituting step “vi.1.” into step “vi.2” gives
              f(x +f(x))=f(x)+x+(f(a)+f(-a)) or f(f(x)+x+f(a)+f(-a))=x+f(x).
              Step "vi.5" Substituting step “vi.1.” into step “vi.3.” gives
              f(x+f(a)+f(-a)+f(x))=x+f(a)+f(-a)+f(x).
              Substituting step “vi.5.” into step “vi.4.” and simplifying gives
              f(x +f(x))=f(x)+x+(f(a)+f(-a)) or f(a)+f(-a)=0.
              The former case simplifies via step “ii.” to f(a)+f(-a)=0,
              so in both cases we have a contradiction. -/
          use .inr$ by_contra$ by hint
        -- Step "vii." Now, consider the case where f(x + f(-x) + f(x)) = f(x).
        /- Step "vii.1": We have f(x + f(x + f(-x) + f(x))) = f(x) + x + f(-x) + f(x)
            or f(f(x) + x + f(-x) + f(x)) = x + f(x + f(-x) + f(x)). -/
        have:=b hz$ hz+(u hz+u (-hz))
        /- Step "vii.2": We have f(f(x + f(-x) + f(x)) + x + f(-x) + f(x)) =
            x + f(-x) + f(x) + f(x + f(-x) + f(x)).
            Step "vii.3": Substituting step “vii.” into step “vii.2.” gives
            f(f(x)+x+f(-x)+f(x))= x+f(-x)+f(x)+f(x).
            Substituting step “vii.” into step “1.” gives
            f(x+f(x))=f(x)+x+f(-x)+f(x) or
            f(f(x)+x+f(-x)+f(x))=x+f(x).
            In the first case we can substitute in step “ii.” and
            simplify to f(-x)+f(x)=0 as desired.
            In the second case we can substitute in step “vii.3” to
            obtain f(-x)+f(x)=0 again as desired. -/
        cases b (hz+(u hz+u (-hz)))$ hz+(u hz+u (-hz))with|_=>hint
      -- Step "g.": Now, consider the case where  f(f(x) + a) = x + f(a).
      /- Step "i.": We have f(-x + f(f(x) + a)) = f(-x) + (f(x) + a) or
          f(f(-x) + f(x) + a) = -x + f(f(x) + a). -/
      have:=b (-hz) (u hz+a)
      have:=b$ -a
      /- Step "ii." We have f(-a + f(f(x) + a)) = f(-a) + (f(x) + a) or
          f(f(-a) + (f(x) + a)) = -a + f(f(x) + a). -/
      specialize this (u hz+a)
      /- Step "iii.": Substituting step “g.” into step “i.” gives
          f(f(a)) = f(-x) + (f(x) + a) or f(f(-x) + f(x) + a) = f(a).
  .      Step "iv.": Substituting step “g.” into step “ii.” gives
          f(-a + x + f(a)) = f(-a) + f(x) + a or
          f(f(-a) + f(x) + a) = -a + x + f(a). -/
      simp_all[ ←add_assoc]
      have:=b 0
      have:=b
      -- Step "v.": We have f(a + f(a)) = a + f(a).
      specialize b a a
      simp_all[add_comm]
      /- Step "vi.": We have f(-a + f(a + f(a))) = f(-a) + a + f(a) or
          f(f(-a) + a + f(a)) = -a + f(a + f(a)). -/
      have:=(this<| -a) (↑a + (((u a))): (↑_ :((( _) ) ) )) ..
      /- Step "vii.": Substituting step “v.” into step “vi.” and simplifying gives
          f(f(a)) = a + f(a) + f(-a) or f(a + f(a) + f(-a)) = f(a). -/
      simp_all[add_assoc]
      cases this
      · -- Step "viii.": First, consider the case where f(f(a)) = a + f(a) + f(-a).
        /- Step "viii.1": In this case, step “iii.” simplifies to
            f(a) + f(-a) = f(-x) + f(x) or f(f(-x) + f(x) + a) = f(a).
            In the first case we are done, so we focus only on the second case. -/
        simp_all
        contrapose! IsAquaesulian_def
        simp_all
        exfalso
        /- Step "viii.2": We have
            f(a + f(a + (f(x) + f(-x)))) = a + (f(x) + f(-x)) + f(a) or
            f(a + (f(x) + f(-x)) + f(a)) = a + f(a + (f(x) + f(-x))). -/
        have:=this a (a+(u hz+u ( -hz)))
        simp_all[Ne.symm,Bool]
        /- Step "viii.3": We have
            f(a + f(x) + f(-x) + f(a + f(x) + f(-x))) =
            a + f(x) + f(-x) + f(a + f(x) + f(-x)). -/
        have:=‹∀congr_arg G,_› (a+(u hz+u (-hz)))$ a+(u ↑hz+u ↑( -hz) )
        /- Step "viii.4": Substituting step “viii.1” into step “viii.3” gives
            f(a + f(x) + f(-x) + f(a))=a + f(x) + f(-x) + f(a).
            The result follows by casework on step “viii.2”; In the first case,
            substituting in step “viii.1” followed by step “v.” gives
            f(x) + f(-x) = 0 as desired, and in the second case,
            substituting in step “viiii.4” followed by step “viii.1” gives
            f(x) + f(-x) = 0 again as desired.
        -/
        simp_all
      -- Step "ix.": Now, consider the case where f(a + f(a) + f(-a)) = f(a).
      /- Step "ix.1.": We have f(a + f(a + f(a) + f(-a))) = f(a) + a + f(a) + f(-a)
          or f(f(a) + a + f(a) + f(-a)) = a + f(a + f(a) + f(-a)). -/
      have:=this a (a +(u a+u (-a)))
      /- Step "ix.2.": We have
          f(a + f(a) + f(-a) + f(a + f(a) + f(-a)))
          = a + f(a) + f(-a) + f(a + f(a) + f(-a)).
          Step "ix.3.": Substituting step “ix.” into step “ix.2” gives
          f(a + f(a) + f(-a) +f(a)) = a + f(a) + f(-a) + f(a).
          The result follows by casework on step “ix.1.”: In the first case,
          we can substitute in step “ix.” followed by step “v.” to get f(a)+f(-a)=0,
          and in the second case we can substitute in step “ix.3.”
          followed by step “ix.” to get f(a)+f(-a)=0 again.
          Either way, this contradicts our assumption about a. -/
      cases‹forall Jd S,_› (a+(u a+u (-a))) ( a + (u a +u ↑(-a)))with| _ =>hint
    /- Now let f be an aquaesulian function with f(0) ≠ 0.
        We will derive a contradiction. -/
    simp_all
    /- We have:
        P(0, 0) -> f(f(0)) = f(0),
        P(f(0), f(0)) -> f(f(0) + f(f(0))) = f(0) + f(f(0)) ->
        f(2f(0)) = 2f(0),
        P(0, f(0)) -> f(f(f(0))) = 2f(0) or f(2f(0)) = f(f(0)) ->
        f(0) = 2f(0) or f(2f(0)) = f(0) -> f(0) = 2f(0) or 2f(0) = f(0),
        so f(0) = 0 as desired. -/
    cases b 0 0with|_=>exact absurd (b 0$ (0+(1 *(@(u ↑.((0) )))))^ 01: ↑ ((_)) ) (id$ (by(cases ( b (u 0) ( (u 0)))with|_ => continuity)))
  rintro K V
  -- Now let f(x) = -x + 2⌈x⌉. We claim that f is aquaesulian.
  specialize V $ λ N=>-N+2 *Int.ceil N
  specialize( V $ (IsAquaesulian_def _).mpr _)
  · simp_rw [ ←eq_sub_iff_add_eq']
    /- The functional equation simplifies to
        ⌈x - y + ⌈y⌉ * 2⌉ * 2 = ⌈y⌉ * 2 + ⌈x⌉ * 2 or
        ⌈-x + y + ⌈x⌉ * 2⌉ * 2 = ⌈y⌉ * 2 + ⌈x⌉ * 2. -/
    ring
    use mod_cast@?_
    /- Which is equivalent to:
        (A) ⌈y⌉ + ⌈x⌉ - 1 < x - y + ⌈y⌉ * 2 ≤ ⌈y⌉ + ⌈x⌉ or
        (B) ⌈y⌉ + ⌈x⌉ - 1 < -x + y + ⌈x⌉ * 2 ≤ ⌈y⌉ + ⌈x⌉ -/
    norm_num[<-add_mul,Int.ceil_eq_iff]
    useλc K=>(em _).imp (⟨by linarith[Int.ceil_lt_add_one c,Int.le_ceil K],.⟩) (by repeat use by linarith[.,Int.le_ceil c,or,Int.ceil_lt_add_one$ K])
    /- If x - y + ⌈y⌉ * 2 ≤ ⌈y⌉ + ⌈x⌉ then we have the desired result (A)
        since ⌈y⌉ < y + 1.
        Otherwise, we have ⌈y⌉ + ⌈x⌉ < x - y + ⌈y⌉ * 2 which we negate and
        add ⌈x⌉ * 2 + ⌈y⌉ * 2 to get -x + y + ⌈x⌉ * 2 < ⌈y⌉ + ⌈x⌉,
        from which we get the desired result (B) since ⌈x⌉ < x + 1. -/
  simp_all[Int.ceil_neg, ←add_assoc]
  suffices:2<=V.1.toFinset.card
  · let M:=V.1.toFinset
    norm_num[this,V.2.trans',(Set.ext$ by simp_all[M]: {x :Rat|∃t:Rat, (↑2 ) * ( ⌈ t ⌉:(ℚ ) ) .. + (- (2 *⌊(t)⌋)) = ↑x} = M)]
  /- Finally, we have f(-1) + f(1) = 0 and f(1/2) = f(-1/2) = 2
      as two distinct values of f. Thus, c = 2 is tight as desired. -/
  use Finset.one_lt_card.2$ by exists@0,V.1.mem_toFinset.2 (by exists-1),2,V.1.mem_toFinset.2 (by exists 1/2)
            </code></pre> 
            
            <pre><code>
theorem imo_2024_p6
    (IsAquaesulian : (ℚ → ℚ) → Prop)
    (IsAquaesulian_def : ∀ f, IsAquaesulian f ↔
      ∀ x y, f (x + f y) = f x + y ∨ f (f x + y) = x + f y) :
    IsLeast {(c : ℤ) | ∀ f, IsAquaesulian f → {(f r + f (-r)) | (r : ℚ)}.Finite ∧
      {(f r + f (-r)) | (r : ℚ)}.ncard ≤ c} 2 := by
  exists 2
  intro f hf
  cases Classical.em (f 0 = 0) with
  | inl h0 =>
    have h_zero : ∀ x, f x + f (-x) = 0 ∨ f x + f (-x) = f 0 + f (-0) := by
      intro x
      specialize hf x 0
      cases hf with
      | inl h1 =>
        have h2 := hf (-0) (x + f 0)
        cases h2 with
        | inl h3 =>
          have h4 := hf x x
          cases h4 with
          | inl h5 =>
            have h6 := hf (-x) (x + f x)
            cases h6 with
            | inl h7 =>
              have h8 := hf (x + f (-x) + f x) (x + f (-x) + f x)
              cases h8 with
              | inl h9 =>
                have h10 := hf (-x) (x + f x)
                cases h10 with
                | inl h11 =>
                  have h12 := hf (-0) (x + f 0)
                  cases h12 with
                  | inl h13 =>
                    have h14 := hf (0 + f 0 + f (-0)) (0 + f 0 + f (-0))
                    cases h14 with
                    | inl h15 =>
                      have h16 := hf (0 + f (-0)) (0 + f (-0))
                      cases h16 with
                      | inl h17 =>
                        have h18 := hf (0 + f 0 + f (-0)) (0 + f 0 + f (-0))
                        cases h18 with
                        | inl h19 =>
                          have h20 := hf (0 + f (-0)) (0 + f (-0))
                          cases h20 with
                          | inl h21 =>
                            exact h21
                          | inr h22 =>
                            exact h22
                        | inr h23 =>
                          exact h23
                      | inr h24 =>
                        exact h24
                    | inr h25 =>
                      exact h25
                  | inr h26 =>
                    exact h26
                | inr h27 =>
                  exact h27
              | inr h28 =>
                exact h28
            | inr h29 =>
              exact h29
          | inr h30 =>
            exact h30
      | inr h31 =>
        exact h31
    exact ⟨Set.toFinite _, Set.ncard_le_ncard⟩
  | inr h0 =>
    have h_nonzero : ∃ c, f 0 = 2 * c := by
      use f 0 / 2
    obtain ⟨c, hc⟩ := h_nonzero
    have h_contradiction : f (2 * c) = 2 * c := by
      specialize hf 0 0
      cases hf with
      | inl h1 =>
        have h2 := hf (f 0) (f 0)
        cases h2 with
        | inl h3 =>
          have h4 := hf 0 (f 0)
          cases h4 with
          | inl h5 =>
            have h6 := hf (f 0) 0
            cases h6 with
            | inl h7 =>
              exact h7
            | inr h8 =>
              exact h8
          | inr h9 =>
            exact h9
        | inr h10 =>
          exact h10
      | inr h11 =>
        exact h11
    exfalso
    apply h0
    rw [hc] at h_contradiction
    exact h_contradiction
  rintro k h_bound
  specialize h_bound (λ x => -x + 2 * Int.ceil x)
  simp only [Int.ceil_eq_iff, Int.ceil_neg] at h_bound
  suffices : 2 ≤ h_bound.toFinset.card
  · let M := h_bound.toFinset
    have : {x : ℚ | ∃ t : ℚ, 2 * ⌈t⌉ + -2 * ⌊t⌋ = x} = M := by
      ext x
      simp only [Set.mem_setOf_eq, Set.mem_toFinset]
      split
      · rintro ⟨t, ht⟩
        exact ⟨t, ht⟩
      · rintro ⟨t, ht⟩
        exact ⟨t, ht⟩
    norm_num at this
  use Finset.one_lt_card.2 (by exists 0, h_bound.mem_toFinset.2 ⟨-1⟩, 2, h_bound.mem_toFinset.2 ⟨1/2⟩)
  exact h_bound
            </code></pre> 
          </div>
          <div class="columns">
            <p><small><i>Original</i></small></p>
            
            
            <p><small><i>ImProof</i></small>
          </div>

          <p><strong>Analysis:</strong> Do some analysis.</p>
        </details>
      </section>


        <h1>Analysis</h1>
        <p>We observed the following improvements:</p>
        <ul>
          <li><strong>Readability:</strong> Proof is more readable.</li>
          <li><strong>Efficient:</strong> Proof is more efficient.</li>
          <li><strong>Length:</strong> The number of proof steps was reduced.</li>
        </ul>
        <img src="../assets/images/alphaproof-results.png" alt="AlphaProof Optimization Results">
        <p>Stay tuned for the full dataset and detailed analysis in our upcoming publication.</p>
      </section>
    </article>
    <footer>
      <p>© 2024 Proof Optimization Project</p>
    </footer>
  </main>
</body>
</html>
