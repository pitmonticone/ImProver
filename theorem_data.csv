decl,original_correct,new_correct,original_score,new_score,delta,original_raw,new_raw,total_time
example : (P → Q) ∧ (Q → R) → P → R ,True,True,5,2.0,-60.0,"decl='example : (P → Q) ∧ (Q → R) → P → R ' declID='Tests3.Basic.9_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\n⊢ (P → Q) ∧ (Q → R) → P → R'], tactic='intro h p', nextState=['P Q R S : Prop\nh : (P → Q) ∧ (Q → R)\np : P\n⊢ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  "", declUpToTactic='example : (P → Q) ∧ (Q → R) → P → R := by\n  ', start=152, end=161), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : (P → Q) ∧ (Q → R)\np : P\n⊢ R'], tactic='rcases h with ⟨a,b⟩', nextState=['case intro\nP Q R S : Prop\np : P\na : P → Q\nb : Q → R\n⊢ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  "", declUpToTactic='example : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  ', start=164, end=187), AnnotatedProofStep(prevState=['case intro\nP Q R S : Prop\np : P\na : P → Q\nb : Q → R\n⊢ R'], tactic='apply b', nextState=['case intro\nP Q R S : Prop\np : P\na : P → Q\nb : Q → R\n⊢ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  "", declUpToTactic='example : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  ', start=190, end=197), AnnotatedProofStep(prevState=['case intro\nP Q R S : Prop\np : P\na : P → Q\nb : Q → R\n⊢ Q'], tactic='apply a', nextState=['case intro\nP Q R S : Prop\np : P\na : P → Q\nb : Q → R\n⊢ P'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  "", declUpToTactic='example : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  ', start=200, end=207), AnnotatedProofStep(prevState=['case intro\nP Q R S : Prop\np : P\na : P → Q\nb : Q → R\n⊢ P'], tactic='exact p', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  "", declUpToTactic='example : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  ', start=210, end=217)]","decl='example : (P → Q) ∧ (Q → R) → P → R ' declID='Tests3.Basic.9_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/"" proof=[ProofStep(tactic='intro h p'), ProofStep(tactic='exact h.2 (h.1 p)')]",10.059385776519775
example (h : P → Q) (h1 : P ∧ R) : Q ∧ R ,True,True,4,2.0,-50.0,"decl='example (h : P → Q) (h1 : P ∧ R) : Q ∧ R ' declID='Tests3.Basic.16_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh : P → Q\nh1 : P ∧ R\n⊢ Q ∧ R'], tactic='rcases h1 with ⟨p,r⟩', nextState=['case intro\nP Q R S : Prop\nh : P → Q\np : P\nr : R\n⊢ Q ∧ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  "", declUpToTactic='example (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  ', start=274, end=298), AnnotatedProofStep(prevState=['case intro\nP Q R S : Prop\nh : P → Q\np : P\nr : R\n⊢ Q ∧ R'], tactic='constructor', nextState=['case intro.left\nP Q R S : Prop\nh : P → Q\np : P\nr : R\n⊢ Q', 'case intro.right\nP Q R S : Prop\nh : P → Q\np : P\nr : R\n⊢ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  "", declUpToTactic='example (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  ', start=301, end=312), AnnotatedProofStep(prevState=['case intro.left\nP Q R S : Prop\nh : P → Q\np : P\nr : R\n⊢ Q', 'case intro.right\nP Q R S : Prop\nh : P → Q\np : P\nr : R\n⊢ R'], tactic='exact h p', nextState=['case intro.right\nP Q R S : Prop\nh : P → Q\np : P\nr : R\n⊢ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  "", declUpToTactic='example (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  ', start=315, end=324), AnnotatedProofStep(prevState=['case intro.right\nP Q R S : Prop\nh : P → Q\np : P\nr : R\n⊢ R'], tactic='exact r', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  "", declUpToTactic='example (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  ', start=327, end=334)]","decl='example (h : P → Q) (h1 : P ∧ R) : Q ∧ R ' declID='Tests3.Basic.16_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p"" proof=[ProofStep(tactic='rcases h1 with ⟨p, r⟩'), ProofStep(tactic='exact ⟨h p, r⟩')]",10.061950206756592
example (h : ¬ (P ∧ Q)) : P → ¬ Q ,True,True,6,2.0,-66.66666666666666,"decl='example (h : ¬ (P ∧ Q)) : P → ¬ Q ' declID='Tests3.Basic.22_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\n⊢ P → ¬Q'], tactic='intro p opp', nextState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  "", declUpToTactic='example (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  ', start=384, end=395), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ False'], tactic='have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp', nextState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\nduh : P ∧ Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  "", declUpToTactic='example (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  ', start=398, end=464), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ P ∧ Q'], tactic='constructor', nextState=['case left\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ P', 'case right\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    "", declUpToTactic='example (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    ', start=427, end=438), AnnotatedProofStep(prevState=['case left\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ P', 'case right\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ Q'], tactic='exact p', nextState=['case right\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    "", declUpToTactic='example (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    ', start=443, end=450), AnnotatedProofStep(prevState=['case right\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ Q'], tactic='exact opp', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    "", declUpToTactic='example (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    ', start=455, end=464), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\nduh : P ∧ Q\n⊢ False'], tactic='exact h duh', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  "", declUpToTactic='example (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  ', start=467, end=478)]","decl='example (h : ¬ (P ∧ Q)) : P → ¬ Q ' declID='Tests3.Basic.22_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r"" proof=[ProofStep(tactic='intro p opp'), ProofStep(tactic='exact h ⟨p, opp⟩')]",12.60040807723999
example (h : ¬ (P → Q)) : ¬ Q ,True,False,5,,,"decl='example (h : ¬ (P → Q)) : ¬ Q ' declID='Tests3.Basic.30_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P → Q)\n⊢ ¬Q'], tactic='intro opp', nextState=['P Q R S : Prop\nh : ¬(P → Q)\nopp : Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  "", declUpToTactic='example (h : ¬ (P → Q)) : ¬ Q := by\n  ', start=522, end=531), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P → Q)\nopp : Q\n⊢ False'], tactic='have duh : P → Q := by\n    intro _\n    exact opp', nextState=['P Q R S : Prop\nh : ¬(P → Q)\nopp : Q\nduh : P → Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  "", declUpToTactic='example (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  ', start=534, end=584), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P → Q)\nopp : Q\n⊢ P → Q'], tactic='intro _', nextState=['P Q R S : Prop\nh : ¬(P → Q)\nopp : Q\na✝ : P\n⊢ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    "", declUpToTactic='example (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    ', start=563, end=570), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P → Q)\nopp : Q\na✝ : P\n⊢ Q'], tactic='exact opp', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    "", declUpToTactic='example (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    ', start=575, end=584), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P → Q)\nopp : Q\nduh : P → Q\n⊢ False'], tactic='exact h duh', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  "", declUpToTactic='example (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  ', start=587, end=598)]","decl='example (h : ¬ (P → Q)) : ¬ Q ' declID='Tests3.Basic.30_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh"" proof=[ProofStep(tactic='intro opp'), ProofStep(tactic='exact h (λ _, opp)')]",8.566365957260132
example (h : P ∧ ¬ Q) : ¬ (P → Q) ,True,False,4,,,"decl='example (h : P ∧ ¬ Q) : ¬ (P → Q) ' declID='Tests3.Basic.37_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh : P ∧ ¬Q\n⊢ ¬(P → Q)'], tactic='rcases h with ⟨p,nq⟩', nextState=['case intro\nP Q R S : Prop\np : P\nnq : ¬Q\n⊢ ¬(P → Q)'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  "", declUpToTactic='example (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  ', start=648, end=672), AnnotatedProofStep(prevState=['case intro\nP Q R S : Prop\np : P\nnq : ¬Q\n⊢ ¬(P → Q)'], tactic='intro huh', nextState=['case intro\nP Q R S : Prop\np : P\nnq : ¬Q\nhuh : P → Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  "", declUpToTactic='example (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  ', start=675, end=684), AnnotatedProofStep(prevState=['case intro\nP Q R S : Prop\np : P\nnq : ¬Q\nhuh : P → Q\n⊢ False'], tactic='have duh := huh p', nextState=['case intro\nP Q R S : Prop\np : P\nnq : ¬Q\nhuh : P → Q\nduh : Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  "", declUpToTactic='example (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  ', start=687, end=704), AnnotatedProofStep(prevState=['case intro\nP Q R S : Prop\np : P\nnq : ¬Q\nhuh : P → Q\nduh : Q\n⊢ False'], tactic='contradiction', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  "", declUpToTactic='example (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  ', start=707, end=720)]","decl='example (h : P ∧ ¬ Q) : ¬ (P → Q) ' declID='Tests3.Basic.37_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh"" proof=[ProofStep(tactic='intro h p'), ProofStep(tactic='exact h.2 (h.1 p)'), ProofStep(tactic='rcases h1 with ⟨p, r⟩'), ProofStep(tactic='constructor'), ProofStep(tactic='exact h p'), ProofStep(tactic='exact r'), ProofStep(tactic='intro p opp'), ProofStep(tactic='exact h ⟨p, opp⟩'), ProofStep(tactic='intro opp'), ProofStep(tactic='exact h (λ _, opp)'), ProofStep(tactic='rcases h with ⟨p, nq⟩'), ProofStep(tactic='intro huh'), ProofStep(tactic='exact nq (huh p)')]",15.68274736404419
example (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q ,True,False,5,,,"decl='example (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q ' declID='Tests3.Basic.46_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh1 : P ∨ Q\nh2 : P → R\n⊢ R ∨ Q'], tactic='rcases h1 with a|b', nextState=['case inl\nP Q R S : Prop\nh2 : P → R\na : P\n⊢ R ∨ Q', 'case inr\nP Q R S : Prop\nh2 : P → R\nb : Q\n⊢ R ∨ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  "", declUpToTactic='example (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  ', start=781, end=799), AnnotatedProofStep(prevState=['case inl\nP Q R S : Prop\nh2 : P → R\na : P\n⊢ R ∨ Q', 'case inr\nP Q R S : Prop\nh2 : P → R\nb : Q\n⊢ R ∨ Q'], tactic='left', nextState=['case inl.h\nP Q R S : Prop\nh2 : P → R\na : P\n⊢ R', 'case inr\nP Q R S : Prop\nh2 : P → R\nb : Q\n⊢ R ∨ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  "", declUpToTactic='example (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  ', start=802, end=806), AnnotatedProofStep(prevState=['case inl.h\nP Q R S : Prop\nh2 : P → R\na : P\n⊢ R', 'case inr\nP Q R S : Prop\nh2 : P → R\nb : Q\n⊢ R ∨ Q'], tactic='exact h2 a', nextState=['case inr\nP Q R S : Prop\nh2 : P → R\nb : Q\n⊢ R ∨ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  "", declUpToTactic='example (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  ', start=809, end=819), AnnotatedProofStep(prevState=['case inr\nP Q R S : Prop\nh2 : P → R\nb : Q\n⊢ R ∨ Q'], tactic='right', nextState=['case inr.h\nP Q R S : Prop\nh2 : P → R\nb : Q\n⊢ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  "", declUpToTactic='example (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  ', start=822, end=827), AnnotatedProofStep(prevState=['case inr.h\nP Q R S : Prop\nh2 : P → R\nb : Q\n⊢ Q'], tactic='exact b', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  "", declUpToTactic='example (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  ', start=830, end=837)]","decl='example (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q ' declID='Tests3.Basic.46_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction"" proof=[ProofStep(tactic='intro h p'), ProofStep(tactic='exact h.2 (h.1 p)'), ProofStep(tactic='rcases h1 with ⟨p, r⟩'), ProofStep(tactic='constructor; exact h p; exact r'), ProofStep(tactic='intro p opp'), ProofStep(tactic='exact h ⟨p, opp⟩'), ProofStep(tactic='intro opp'), ProofStep(tactic='exact h (λ _, opp)'), ProofStep(tactic='rcases h with ⟨p, nq⟩'), ProofStep(tactic='intro huh; exact nq (huh p)'), ProofStep(tactic='rcases h1 with a|b'), ProofStep(tactic='left; exact h2 a'), ProofStep(tactic='right; exact b')]",17.608930110931396
example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) ,True,False,11,,,"decl='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) ' declID='Tests3.Basic.54_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh1 : P ∨ Q → R\n⊢ (P → R) ∧ (Q → R)'], tactic='constructor', nextState=['case left\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ P → R', 'case right\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ Q → R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  ', start=903, end=914), AnnotatedProofStep(prevState=['case left\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ P → R', 'case right\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ Q → R'], tactic='intro p', nextState=['case left\nP Q R S : Prop\nh1 : P ∨ Q → R\np : P\n⊢ R', 'case right\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ Q → R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  ', start=917, end=924), AnnotatedProofStep(prevState=['case left\nP Q R S : Prop\nh1 : P ∨ Q → R\np : P\n⊢ R', 'case right\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ Q → R'], tactic='have duh : P ∨ Q := by\n    left\n    exact p', nextState=['case left\nP Q R S : Prop\nh1 : P ∨ Q → R\np : P\nduh : P ∨ Q\n⊢ R', 'case right\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ Q → R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  ', start=927, end=972), AnnotatedProofStep(prevState=['P Q R S : Prop\nh1 : P ∨ Q → R\np : P\n⊢ P ∨ Q'], tactic='left', nextState=['case h\nP Q R S : Prop\nh1 : P ∨ Q → R\np : P\n⊢ P'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    ', start=956, end=960), AnnotatedProofStep(prevState=['case h\nP Q R S : Prop\nh1 : P ∨ Q → R\np : P\n⊢ P'], tactic='exact p', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    ', start=965, end=972), AnnotatedProofStep(prevState=['case left\nP Q R S : Prop\nh1 : P ∨ Q → R\np : P\nduh : P ∨ Q\n⊢ R', 'case right\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ Q → R'], tactic='exact h1 duh', nextState=['case right\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ Q → R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  ', start=975, end=987), AnnotatedProofStep(prevState=['case right\nP Q R S : Prop\nh1 : P ∨ Q → R\n⊢ Q → R'], tactic='intro q', nextState=['case right\nP Q R S : Prop\nh1 : P ∨ Q → R\nq : Q\n⊢ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  ', start=990, end=997), AnnotatedProofStep(prevState=['case right\nP Q R S : Prop\nh1 : P ∨ Q → R\nq : Q\n⊢ R'], tactic='have duh : P ∨ Q := by\n    right\n    exact q', nextState=['case right\nP Q R S : Prop\nh1 : P ∨ Q → R\nq : Q\nduh : P ∨ Q\n⊢ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  ', start=1000, end=1046), AnnotatedProofStep(prevState=['P Q R S : Prop\nh1 : P ∨ Q → R\nq : Q\n⊢ P ∨ Q'], tactic='right', nextState=['case h\nP Q R S : Prop\nh1 : P ∨ Q → R\nq : Q\n⊢ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    ', start=1029, end=1034), AnnotatedProofStep(prevState=['case h\nP Q R S : Prop\nh1 : P ∨ Q → R\nq : Q\n⊢ Q'], tactic='exact q', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    ', start=1039, end=1046), AnnotatedProofStep(prevState=['case right\nP Q R S : Prop\nh1 : P ∨ Q → R\nq : Q\nduh : P ∨ Q\n⊢ R'], tactic='exact h1 duh', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  "", declUpToTactic='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  ', start=1049, end=1061)]","decl='example (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) ' declID='Tests3.Basic.54_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b"" proof=[ProofStep(tactic='intro h p; exact h.2 (h.1 p)'), ProofStep(tactic='rcases h1 with ⟨p, r⟩; exact ⟨h p, r⟩'), ProofStep(tactic='intros p opp; exact h ⟨p, opp⟩'), ProofStep(tactic='intro opp; exact h (λ _, opp)'), ProofStep(tactic='rcases h with ⟨p, nq⟩; intro huh; exact nq (huh p)'), ProofStep(tactic='rcases h1 with a|b; [left, exact h2 a | right, exact b]'), ProofStep(tactic='split; { intro x, exact h1 (or.inl x) <|> exact h1 (or.inr x) }')]",13.48771619796753
example (h1 : P → R) (h2 : Q → R) : P ∨ Q → R ,True,False,4,,,"decl='example (h1 : P → R) (h2 : Q → R) : P ∨ Q → R ' declID='Tests3.Basic.68_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh1 : P → R\nh2 : Q → R\n⊢ P ∨ Q → R'], tactic='intro pq', nextState=['P Q R S : Prop\nh1 : P → R\nh2 : Q → R\npq : P ∨ Q\n⊢ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  "", declUpToTactic='example (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  ', start=1126, end=1134), AnnotatedProofStep(prevState=['P Q R S : Prop\nh1 : P → R\nh2 : Q → R\npq : P ∨ Q\n⊢ R'], tactic='rcases pq with a|b', nextState=['case inl\nP Q R S : Prop\nh1 : P → R\nh2 : Q → R\na : P\n⊢ R', 'case inr\nP Q R S : Prop\nh1 : P → R\nh2 : Q → R\nb : Q\n⊢ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  "", declUpToTactic='example (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  ', start=1137, end=1155), AnnotatedProofStep(prevState=['case inl\nP Q R S : Prop\nh1 : P → R\nh2 : Q → R\na : P\n⊢ R', 'case inr\nP Q R S : Prop\nh1 : P → R\nh2 : Q → R\nb : Q\n⊢ R'], tactic='exact h1 a', nextState=['case inr\nP Q R S : Prop\nh1 : P → R\nh2 : Q → R\nb : Q\n⊢ R'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  "", declUpToTactic='example (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  ', start=1158, end=1168), AnnotatedProofStep(prevState=['case inr\nP Q R S : Prop\nh1 : P → R\nh2 : Q → R\nb : Q\n⊢ R'], tactic='exact h2 b', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  "", declUpToTactic='example (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  ', start=1171, end=1181)]","decl='example (h1 : P → R) (h2 : Q → R) : P ∨ Q → R ' declID='Tests3.Basic.68_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh"" proof=[ProofStep(tactic='intro h p'), ProofStep(tactic='exact h.2 (h.1 p)'), ProofStep(tactic='rcases h1 with ⟨p, r⟩'), ProofStep(tactic='constructor'), ProofStep(tactic='exact h p'), ProofStep(tactic='exact r'), ProofStep(tactic='intro p opp'), ProofStep(tactic='exact h ⟨p, opp⟩'), ProofStep(tactic='intro opp'), ProofStep(tactic='exact h (λ _, opp)'), ProofStep(tactic='rcases h with ⟨p, nq⟩'), ProofStep(tactic='intro huh'), ProofStep(tactic='contradiction'), ProofStep(tactic='rcases h1 with a|b'), ProofStep(tactic='left'), ProofStep(tactic='exact h2 a'), ProofStep(tactic='right'), ProofStep(tactic='exact b'), ProofStep(tactic='constructor'), ProofStep(tactic='intro p'), ProofStep(tactic='exact h1 (Or.inl p)'), ProofStep(tactic='intro q'), ProofStep(tactic='exact h1 (Or.inr q)'), ProofStep(tactic='intro pq'), ProofStep(tactic='cases pq'), ProofStep(tactic='exact h1 pq'), ProofStep(tactic='exact h2 pq')]",17.861591815948486
example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q ,True,True,11,5.0,-54.54545454545454,"decl='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q ' declID='Tests3.Basic.75_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬P ∧ ¬Q'], tactic='constructor', nextState=['case left\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬P', 'case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  ', start=1235, end=1246), AnnotatedProofStep(prevState=['case left\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬P', 'case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬Q'], tactic='intro p', nextState=['case left\nP Q R S : Prop\nh : ¬(P ∨ Q)\np : P\n⊢ False', 'case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  ', start=1249, end=1256), AnnotatedProofStep(prevState=['case left\nP Q R S : Prop\nh : ¬(P ∨ Q)\np : P\n⊢ False', 'case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬Q'], tactic='have duh : P∨ Q := by\n    left\n    exact p', nextState=['case left\nP Q R S : Prop\nh : ¬(P ∨ Q)\np : P\nduh : P ∨ Q\n⊢ False', 'case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  ', start=1259, end=1303), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∨ Q)\np : P\n⊢ P ∨ Q'], tactic='left', nextState=['case h\nP Q R S : Prop\nh : ¬(P ∨ Q)\np : P\n⊢ P'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    ', start=1287, end=1291), AnnotatedProofStep(prevState=['case h\nP Q R S : Prop\nh : ¬(P ∨ Q)\np : P\n⊢ P'], tactic='exact p', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    ', start=1296, end=1303), AnnotatedProofStep(prevState=['case left\nP Q R S : Prop\nh : ¬(P ∨ Q)\np : P\nduh : P ∨ Q\n⊢ False', 'case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬Q'], tactic='exact h duh', nextState=['case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  ', start=1306, end=1317), AnnotatedProofStep(prevState=['case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\n⊢ ¬Q'], tactic='intro q', nextState=['case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\nq : Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  ', start=1320, end=1327), AnnotatedProofStep(prevState=['case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\nq : Q\n⊢ False'], tactic='have duh : P∨ Q := by\n    right\n    exact q', nextState=['case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\nq : Q\nduh : P ∨ Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  ', start=1330, end=1375), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∨ Q)\nq : Q\n⊢ P ∨ Q'], tactic='right', nextState=['case h\nP Q R S : Prop\nh : ¬(P ∨ Q)\nq : Q\n⊢ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    ', start=1358, end=1363), AnnotatedProofStep(prevState=['case h\nP Q R S : Prop\nh : ¬(P ∨ Q)\nq : Q\n⊢ Q'], tactic='exact q', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    ', start=1368, end=1375), AnnotatedProofStep(prevState=['case right\nP Q R S : Prop\nh : ¬(P ∨ Q)\nq : Q\nduh : P ∨ Q\n⊢ False'], tactic='exact h duh', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  "", declUpToTactic='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  ', start=1378, end=1389)]","decl='example (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q ' declID='Tests3.Basic.75_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b"" proof=[ProofStep(tactic='constructor'), ProofStep(tactic='intro p'), ProofStep(tactic='exact h (Or.inl p)'), ProofStep(tactic='intro q'), ProofStep(tactic='exact h (Or.inr q)')]",10.294754981994629
example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q ,True,False,12,,,"decl='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q ' declID='Tests3.Basic.89_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\n⊢ ¬P ∨ ¬Q'], tactic='have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh', nextState=['P Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\n⊢ ¬P ∨ ¬Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  ', start=1480, end=1616), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\n⊢ P → ¬Q'], tactic='intro p opp', nextState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    ', start=1512, end=1523), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ False'], tactic='have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp', nextState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\nduh : P ∧ Q\n⊢ False'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    ', start=1528, end=1600), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ P ∧ Q'], tactic='constructor', nextState=['case left\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ P', 'case right\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      ', start=1559, end=1570), AnnotatedProofStep(prevState=['case left\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ P', 'case right\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ Q'], tactic='exact p', nextState=['case right\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      ', start=1577, end=1584), AnnotatedProofStep(prevState=['case right\nP Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\n⊢ Q'], tactic='exact opp', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      ', start=1591, end=1600), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\np : P\nopp : Q\nduh : P ∧ Q\n⊢ False'], tactic='exact h duh', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    ', start=1605, end=1616), AnnotatedProofStep(prevState=['P Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\n⊢ ¬P ∨ ¬Q'], tactic='by_cases duh:P', nextState=['case pos\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : P\n⊢ ¬P ∨ ¬Q', 'case neg\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : ¬P\n⊢ ¬P ∨ ¬Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  ', start=1622, end=1636), AnnotatedProofStep(prevState=['case pos\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : P\n⊢ ¬P ∨ ¬Q', 'case neg\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : ¬P\n⊢ ¬P ∨ ¬Q'], tactic='right', nextState=['case pos.h\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : P\n⊢ ¬Q', 'case neg\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : ¬P\n⊢ ¬P ∨ ¬Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  ', start=1639, end=1644), AnnotatedProofStep(prevState=['case pos.h\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : P\n⊢ ¬Q', 'case neg\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : ¬P\n⊢ ¬P ∨ ¬Q'], tactic='exact hmm duh', nextState=['case neg\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : ¬P\n⊢ ¬P ∨ ¬Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  ', start=1647, end=1660), AnnotatedProofStep(prevState=['case neg\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : ¬P\n⊢ ¬P ∨ ¬Q'], tactic='left', nextState=['case neg.h\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : ¬P\n⊢ ¬P'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  ', start=1663, end=1667), AnnotatedProofStep(prevState=['case neg.h\nP Q R S : Prop\nh : ¬(P ∧ Q)\nhmm : P → ¬Q\nduh : ¬P\n⊢ ¬P'], tactic='exact duh', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  left\n  "", declUpToTactic='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  left\n  ', start=1670, end=1679)]","decl='example (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q ' declID='Tests3.Basic.89_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!"" proof=[ProofStep(tactic='intro h p; exact h.2 (h.1 p)'), ProofStep(tactic='rcases h1 with ⟨p, r⟩; exact ⟨h p, r⟩'), ProofStep(tactic='intro p opp; exact h ⟨p, opp⟩'), ProofStep(tactic='intro opp; exact h (λ _, opp)'), ProofStep(tactic='rcases h with ⟨p, nq⟩; intro huh; exact nq (huh p)'), ProofStep(tactic='rcases h1 with a|b; [left, exact h2 a | right, exact b]'), ProofStep(tactic='constructor; { intro p; exact h1 (or.inl p) }, { intro q; exact h1 (or.inr q) }'), ProofStep(tactic='intro pq; rcases pq with a|b; [exact h1 a, exact h2 b]'), ProofStep(tactic='constructor; { intro p; exact h (or.inl p) }, { intro q; exact h (or.inr q) }'), ProofStep(tactic='by_cases P; [right, exact (λ opp, h ⟨duh, opp⟩) | left, exact duh]')]",19.4151508808136
example (h : P → Q) : ¬ P ∨ Q ,True,False,5,,,"decl='example (h : P → Q) : ¬ P ∨ Q ' declID='Tests3.Basic.108_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  left\n  exact duh\n\n\n-- this one too"" proof=[AnnotatedProofStep(prevState=['P Q R S : Prop\nh : P → Q\n⊢ ¬P ∨ Q'], tactic='by_cases duh:P', nextState=['case pos\nP Q R S : Prop\nh : P → Q\nduh : P\n⊢ ¬P ∨ Q', 'case neg\nP Q R S : Prop\nh : P → Q\nduh : ¬P\n⊢ ¬P ∨ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  left\n  exact duh\n\n\n-- this one too\nexample (h : P → Q) : ¬ P ∨ Q := by\n  "", declUpToTactic='example (h : P → Q) : ¬ P ∨ Q := by\n  ', start=1741, end=1755), AnnotatedProofStep(prevState=['case pos\nP Q R S : Prop\nh : P → Q\nduh : P\n⊢ ¬P ∨ Q', 'case neg\nP Q R S : Prop\nh : P → Q\nduh : ¬P\n⊢ ¬P ∨ Q'], tactic='right', nextState=['case pos.h\nP Q R S : Prop\nh : P → Q\nduh : P\n⊢ Q', 'case neg\nP Q R S : Prop\nh : P → Q\nduh : ¬P\n⊢ ¬P ∨ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  left\n  exact duh\n\n\n-- this one too\nexample (h : P → Q) : ¬ P ∨ Q := by\n  by_cases duh:P\n  "", declUpToTactic='example (h : P → Q) : ¬ P ∨ Q := by\n  by_cases duh:P\n  ', start=1758, end=1763), AnnotatedProofStep(prevState=['case pos.h\nP Q R S : Prop\nh : P → Q\nduh : P\n⊢ Q', 'case neg\nP Q R S : Prop\nh : P → Q\nduh : ¬P\n⊢ ¬P ∨ Q'], tactic='exact h duh', nextState=['case neg\nP Q R S : Prop\nh : P → Q\nduh : ¬P\n⊢ ¬P ∨ Q'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  left\n  exact duh\n\n\n-- this one too\nexample (h : P → Q) : ¬ P ∨ Q := by\n  by_cases duh:P\n  right\n  "", declUpToTactic='example (h : P → Q) : ¬ P ∨ Q := by\n  by_cases duh:P\n  right\n  ', start=1766, end=1777), AnnotatedProofStep(prevState=['case neg\nP Q R S : Prop\nh : P → Q\nduh : ¬P\n⊢ ¬P ∨ Q'], tactic='left', nextState=['case neg.h\nP Q R S : Prop\nh : P → Q\nduh : ¬P\n⊢ ¬P'], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  left\n  exact duh\n\n\n-- this one too\nexample (h : P → Q) : ¬ P ∨ Q := by\n  by_cases duh:P\n  right\n  exact h duh\n  "", declUpToTactic='example (h : P → Q) : ¬ P ∨ Q := by\n  by_cases duh:P\n  right\n  exact h duh\n  ', start=1780, end=1784), AnnotatedProofStep(prevState=['case neg.h\nP Q R S : Prop\nh : P → Q\nduh : ¬P\n⊢ ¬P'], tactic='exact duh', nextState=[], srcUpToTactic=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  left\n  exact duh\n\n\n-- this one too\nexample (h : P → Q) : ¬ P ∨ Q := by\n  by_cases duh:P\n  right\n  exact h duh\n  left\n  "", declUpToTactic='example (h : P → Q) : ¬ P ∨ Q := by\n  by_cases duh:P\n  right\n  exact h duh\n  left\n  ', start=1787, end=1796)]","decl='example (h : P → Q) : ¬ P ∨ Q ' declID='Tests3.Basic.108_0.uYILNYVbOxR91M9' src='Tests3' leanFile='Tests3/Basic' context=""import Mathlib.Tactic\n\nvariable (P Q R S : Prop)\n\n/-\nReplace the following sorry's by proofs.\n-/\n\nexample : (P → Q) ∧ (Q → R) → P → R := by\n  intro h p\n  rcases h with ⟨a,b⟩\n  apply b\n  apply a\n  exact p\n\nexample (h : P → Q) (h1 : P ∧ R) : Q ∧ R := by\n  rcases h1 with ⟨p,r⟩\n  constructor\n  exact h p\n  exact r\n\nexample (h : ¬ (P ∧ Q)) : P → ¬ Q := by\n  intro p opp\n  have duh : P ∧ Q := by\n    constructor\n    exact p\n    exact opp\n  exact h duh\n\nexample (h : ¬ (P → Q)) : ¬ Q := by\n  intro opp\n  have duh : P → Q := by\n    intro _\n    exact opp\n  exact h duh\n\nexample (h : P ∧ ¬ Q) : ¬ (P → Q) := by\n  rcases h with ⟨p,nq⟩\n  intro huh\n  have duh := huh p\n  contradiction\n\n\n\n\nexample (h1 : P ∨ Q) (h2 : P → R) : R ∨ Q := by\n  rcases h1 with a|b\n  left\n  exact h2 a\n  right\n  exact b\n\n\nexample (h1 : P ∨ Q → R) : (P → R) ∧ (Q → R) := by\n  constructor\n  intro p\n  have duh : P ∨ Q := by\n    left\n    exact p\n  exact h1 duh\n  intro q\n  have duh : P ∨ Q := by\n    right\n    exact q\n  exact h1 duh\n\n\nexample (h1 : P → R) (h2 : Q → R) : P ∨ Q → R := by\n  intro pq\n  rcases pq with a|b\n  exact h1 a\n  exact h2 b\n\n\nexample (h : ¬ (P ∨ Q)) : ¬ P ∧ ¬ Q := by\n  constructor\n  intro p\n  have duh : P∨ Q := by\n    left\n    exact p\n  exact h duh\n  intro q\n  have duh : P∨ Q := by\n    right\n    exact q\n  exact h duh\n\n-- this one requires classical logic!\nexample (h : ¬ (P ∧ Q)) : ¬ P ∨ ¬ Q := by\n  have hmm : P → ¬ Q := by\n    intro p opp\n    have duh : P ∧ Q := by\n      constructor\n      exact p\n      exact opp\n    exact h duh\n\n\n\n  by_cases duh:P\n  right\n  exact hmm duh\n  left\n  exact duh\n\n\n-- this one too"" proof=[ProofStep(tactic='intro h p; exact h.2 (h.1 p)'), ProofStep(tactic='rcases h1 with ⟨p, r⟩; exact ⟨h p, r⟩'), ProofStep(tactic='intro p opp; exact h ⟨p, opp⟩'), ProofStep(tactic='intro opp; exact h (λ _, opp)'), ProofStep(tactic='rcases h with ⟨p, nq⟩; intro huh; exact nq (huh p)'), ProofStep(tactic='rcases h1 with a|b; [left, exact h2 a | right, exact b]'), ProofStep(tactic='constructor; { intro p; exact h1 (or.inl p) }, { intro q; exact h1 (or.inr q) }'), ProofStep(tactic='intro pq; cases pq; [exact h1 pq, exact h2 pq]'), ProofStep(tactic='constructor; { intro p; exact h (or.inl p) }, { intro q; exact h (or.inr q) }'), ProofStep(tactic='by_cases duh:P; [right, exact (λ p opp, h ⟨p, opp⟩) duh | left, exact duh]'), ProofStep(tactic='by_cases duh:P; [right, exact h duh | left, exact duh]')]",22.62035298347473
