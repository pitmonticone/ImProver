repo,file,decl,method,n,metric,model,annotation,syntax_search,mathlib_search,examples,og_correct,og_errors,og_score,new_correct,new_errors,new_score,delta,og_raw,new_raw,time
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :
    x * (x - algebraMap R A r) = (x - algebraMap R A r) * x ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,True,,0.46652439024390246,-0.44128815539652405,"theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :
    x * (x - algebraMap R A r) = (x - algebraMap R A r) * x := by rw [mul_sub, ← commutes, sub_mul]","

theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :
    x * (x - algebraMap R A r) = (x - algebraMap R A r) * x  := by
  intros
  rw [mul_sub, ← Algebra.commutes, sub_mul]
",7.282026052474976
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :
    x * (x - algebraMap R A r) = (x - algebraMap R A r) * x ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,True,,0.6821929824561404,-0.18300241622019128,"theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :
    x * (x - algebraMap R A r) = (x - algebraMap R A r) * x := by rw [mul_sub, ← commutes, sub_mul]","

theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :
    x * (x - algebraMap R A r) = (x - algebraMap R A r) * x  := by
  theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :
      x * (x - algebraMap R A r) = (x - algebraMap R A r) * x := by
    rw [mul_sub, ← commutes, sub_mul]
",47.20999097824097
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem mul_sub_algebraMap_pow_commutes [Ring A] [Algebra R A] (x : A) (r : R) (n : ℕ) :
    x * (x - algebraMap R A r) ^ n = (x - algebraMap R A r) ^ n * x ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.4024603174603174,True,,0.3474603174603174,-0.1366594360086768,"theorem mul_sub_algebraMap_pow_commutes [Ring A] [Algebra R A] (x : A) (r : R) (n : ℕ) :
    x * (x - algebraMap R A r) ^ n = (x - algebraMap R A r) ^ n * x := by
  induction' n with n ih
  · simp
  · rw [pow_succ', ← mul_assoc, mul_sub_algebraMap_commutes, mul_assoc, ih, ← mul_assoc]","

theorem mul_sub_algebraMap_pow_commutes [Ring A] [Algebra R A] (x : A) (r : R) (n : ℕ) :
    x * (x - algebraMap R A r) ^ n = (x - algebraMap R A r) ^ n * x  := by
  induction' n with n ih
  simp
  rw [pow_succ', ← mul_assoc, mul_sub_algebraMap_commutes, mul_assoc, ih, ← mul_assoc]
",7.393564939498901
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem mul_sub_algebraMap_pow_commutes [Ring A] [Algebra R A] (x : A) (r : R) (n : ℕ) :
    x * (x - algebraMap R A r) ^ n = (x - algebraMap R A r) ^ n * x ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.4024603174603174,True,,0.42386363636363633,0.05318119072802573,"theorem mul_sub_algebraMap_pow_commutes [Ring A] [Algebra R A] (x : A) (r : R) (n : ℕ) :
    x * (x - algebraMap R A r) ^ n = (x - algebraMap R A r) ^ n * x := by
  induction' n with n ih
  · simp
  · rw [pow_succ', ← mul_assoc, mul_sub_algebraMap_commutes, mul_assoc, ih, ← mul_assoc]","

theorem mul_sub_algebraMap_pow_commutes [Ring A] [Algebra R A] (x : A) (r : R) (n : ℕ) :
    x * (x - algebraMap R A r) ^ n = (x - algebraMap R A r) ^ n * x  := by
  induction n with
    | zero => simp
    | succ n ih =>
      rw [pow_succ', ← mul_assoc, mul_sub_algebraMap_commutes, mul_assoc, ih, ← mul_assoc]
",47.91535830497742
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- A `Semiring` that is an `Algebra` over a commutative ring carries a natural `Ring` structure.
See note [reducible non-instances]. -/
abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.45018292682926836,False,"unexpected token '/--'; expected term
	at: 

/-- 
unexpected token '/--'; expected '{' or tactic
	at: 
  /-- 
'Algebra.semiringToRing' has already been declared
	at:   abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A :=",,,"/-- A `Semiring` that is an `Algebra` over a commutative ring carries a natural `Ring` structure.
See note [reducible non-instances]. -/
abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A :=
  { __ := (inferInstance : Semiring A)
    __ := Module.addCommMonoidToAddCommGroup R
    intCast := fun z => algebraMap R A z
    intCast_ofNat := fun z => by simp only [Int.cast_natCast, map_natCast]
    intCast_negSucc := fun z => by simp }","

/-- A `Semiring` that is an `Algebra` over a commutative ring carries a natural `Ring` structure.
See note [reducible non-instances]. -/
abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A  := by
  /-- A `Semiring` that is an `Algebra` over a commutative ring carries a natural `Ring` structure.
  See note [reducible non-instances]. -/
  abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A :=
  {
    __ := (inferInstance : Semiring A),
    __ := Module.addCommMonoidToAddCommGroup R,
    intCast := fun z => algebraMap R A z,
    intCast_ofNat := fun z => by simp only [Int.cast_natCast, map_natCast],
    intCast_negSucc := fun z => by simp
  }
",10.041072130203247
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- A `Semiring` that is an `Algebra` over a commutative ring carries a natural `Ring` structure.
See note [reducible non-instances]. -/
abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.45018292682926836,False,"unexpected token '/--'; expected term
	at: 

/-- 
unexpected token '/--'; expected '{' or tactic
	at: 
  /-- 
'Algebra.semiringToRing' has already been declared
	at:   abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A :=",,,"/-- A `Semiring` that is an `Algebra` over a commutative ring carries a natural `Ring` structure.
See note [reducible non-instances]. -/
abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A :=
  { __ := (inferInstance : Semiring A)
    __ := Module.addCommMonoidToAddCommGroup R
    intCast := fun z => algebraMap R A z
    intCast_ofNat := fun z => by simp only [Int.cast_natCast, map_natCast]
    intCast_negSucc := fun z => by simp }","

/-- A `Semiring` that is an `Algebra` over a commutative ring carries a natural `Ring` structure.
See note [reducible non-instances]. -/
abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A  := by
  /-- A `Semiring` that is an `Algebra` over a commutative ring carries a natural `Ring` structure.
  See note [reducible non-instances]. -/
  abbrev semiringToRing [Semiring A] [Algebra R A] : Ring A :=
  {
    toSemiring := inferInstance
    toAddCommGroup := Module.addCommMonoidToAddCommGroup R
    intCast := fun z => algebraMap R A z
    intCast_ofNat := fun z => by
      simp only [Int.cast_natCast, map_natCast]
    intCast_negSucc := fun z => by
      simp
  }
",42.794212102890015
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    (↑(h.unit⁻¹) : Module.End S M) m = m' ↔ m = x • m' ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.42190476190476195,False,"unexpected token 'theorem'; expected term
	at: 

theorem 
unexpected token 'theorem'; expected '{' or tactic
	at: 
  theorem 
unexpected token ','; expected ':='
	at:           erw [End_isUnit_apply_inv_apply_of_isUnit],",,,"theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    (↑(h.unit⁻¹) : Module.End S M) m = m' ↔ m = x • m' :=
  { mp := fun H => ((congr_arg h.unit H).symm.trans (End_isUnit_apply_inv_apply_of_isUnit h _)).symm
    mpr := fun H =>
      H.symm ▸ by
        apply_fun ⇑h.unit.val using ((Module.End_isUnit_iff _).mp h).injective
        erw [End_isUnit_apply_inv_apply_of_isUnit]
        rfl }","

theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    (↑(h.unit⁻¹) : Module.End S M) m = m' ↔ m = x • m'  := by
  theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}
      (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
      (↑(h.unit⁻¹) : Module.End S M) m = m' ↔ m = x • m' :=
    {
      mp := fun H =>
        (congr_arg h.unit H).symm.trans (End_isUnit_apply_inv_apply_of_isUnit h _).symm,
      mpr := fun H =>
        H.symm ▸ by
          apply_fun ⇑h.unit.val using ((Module.End_isUnit_iff _).mp h).injective,
          erw [End_isUnit_apply_inv_apply_of_isUnit],
          rfl
    }
",11.909373044967651
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    (↑(h.unit⁻¹) : Module.End S M) m = m' ↔ m = x • m' ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.42190476190476195,False,"unexpected token 'theorem'; expected term
	at: 

theorem 
unexpected token 'theorem'; expected '{' or tactic
	at: 
  theorem 
unexpected token ','; expected ':='
	at:           erw [End_isUnit_apply_inv_apply_of_isUnit],",,,"theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    (↑(h.unit⁻¹) : Module.End S M) m = m' ↔ m = x • m' :=
  { mp := fun H => ((congr_arg h.unit H).symm.trans (End_isUnit_apply_inv_apply_of_isUnit h _)).symm
    mpr := fun H =>
      H.symm ▸ by
        apply_fun ⇑h.unit.val using ((Module.End_isUnit_iff _).mp h).injective
        erw [End_isUnit_apply_inv_apply_of_isUnit]
        rfl }","

theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    (↑(h.unit⁻¹) : Module.End S M) m = m' ↔ m = x • m'  := by
  theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}
      (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
      (↑(h.unit⁻¹) : Module.End S M) m = m' ↔ m = x • m' :=
    { mp := fun H =>
        ((congr_arg h.unit H).symm.trans (End_isUnit_apply_inv_apply_of_isUnit h _)).symm,
      mpr := fun H =>
        H.symm ▸ by
          apply_fun ⇑h.unit.val using ((Module.End_isUnit_iff _).mp h).injective,
          erw [End_isUnit_apply_inv_apply_of_isUnit],
          rfl }
",60.572246074676514
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    m' = (↑h.unit⁻¹ : Module.End S M) m ↔ m = x • m' ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.4105701754385965,False,"unexpected token 'theorem'; expected term
	at: 

theorem 
'Module.End_algebraMap_isUnit_inv_apply_eq_iff'' has already been declared
	at: theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}
unexpected token ','; expected command
	at:    },",,,"theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    m' = (↑h.unit⁻¹ : Module.End S M) m ↔ m = x • m' :=
  { mp := fun H => ((congr_arg h.unit H).trans (End_isUnit_apply_inv_apply_of_isUnit h _)).symm
    mpr := fun H =>
      H.symm ▸ by
        apply_fun (↑h.unit : M → M) using ((Module.End_isUnit_iff _).mp h).injective
        erw [End_isUnit_apply_inv_apply_of_isUnit]
        rfl }","

theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    m' = (↑h.unit⁻¹ : Module.End S M) m ↔ m = x • m'  := by
  intros
  split
   {
     intro H
     apply (congr_arg h.unit H).trans
     apply (End_isUnit_apply_inv_apply_of_isUnit h _).symm
   },
   {
     intro H
     rw [H.symm]
     apply_fun (↑h.unit : M → M) using ((Module.End_isUnit_iff _).mp h).injective
     erw [End_isUnit_apply_inv_apply_of_isUnit]
     rfl
   }
",9.266400814056396
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    m' = (↑h.unit⁻¹ : Module.End S M) m ↔ m = x • m' ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.4105701754385965,False,"unexpected token 'theorem'; expected term
	at: 

theorem 
unexpected token 'theorem'; expected '{' or tactic
	at: 
  theorem 
unexpected token ','; expected ':='
	at:           erw [End_isUnit_apply_inv_apply_of_isUnit],",,,"theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    m' = (↑h.unit⁻¹ : Module.End S M) m ↔ m = x • m' :=
  { mp := fun H => ((congr_arg h.unit H).trans (End_isUnit_apply_inv_apply_of_isUnit h _)).symm
    mpr := fun H =>
      H.symm ▸ by
        apply_fun (↑h.unit : M → M) using ((Module.End_isUnit_iff _).mp h).injective
        erw [End_isUnit_apply_inv_apply_of_isUnit]
        rfl }","

theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}
    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    m' = (↑h.unit⁻¹ : Module.End S M) m ↔ m = x • m'  := by
  theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R} (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :
    m' = (↑h.unit⁻¹ : Module.End S M) m ↔ m = x • m' := 
    {
      mp := fun H =>
        (congr_arg h.unit H).trans (End_isUnit_apply_inv_apply_of_isUnit h _).symm,
      mpr := fun H =>
        H.symm ▸ by
          apply_fun (↑h.unit : M → M) using ((Module.End_isUnit_iff _).mp h).injective,
          erw [End_isUnit_apply_inv_apply_of_isUnit],
          rfl
    }
",54.816617012023926
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- An alternate statement of `LinearMap.map_smul` for when `algebraMap` is more convenient to
work with than `•`. -/
theorem map_algebraMap_mul (f : A →ₗ[R] B) (a : A) (r : R) :
    f (algebraMap R A r * a) = algebraMap R B r * f a ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,True,,0.8350000000000001,0.0,"/-- An alternate statement of `LinearMap.map_smul` for when `algebraMap` is more convenient to
work with than `•`. -/
theorem map_algebraMap_mul (f : A →ₗ[R] B) (a : A) (r : R) :
    f (algebraMap R A r * a) = algebraMap R B r * f a := by
  rw [← Algebra.smul_def, ← Algebra.smul_def, map_smul]","

/-- An alternate statement of `LinearMap.map_smul` for when `algebraMap` is more convenient to
work with than `•`. -/
theorem map_algebraMap_mul (f : A →ₗ[R] B) (a : A) (r : R) :
    f (algebraMap R A r * a) = algebraMap R B r * f a  := by
  rw [← Algebra.smul_def, ← Algebra.smul_def, map_smul]
",5.848747968673706
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- An alternate statement of `LinearMap.map_smul` for when `algebraMap` is more convenient to
work with than `•`. -/
theorem map_algebraMap_mul (f : A →ₗ[R] B) (a : A) (r : R) :
    f (algebraMap R A r * a) = algebraMap R B r * f a ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,True,,0.8350000000000001,0.0,"/-- An alternate statement of `LinearMap.map_smul` for when `algebraMap` is more convenient to
work with than `•`. -/
theorem map_algebraMap_mul (f : A →ₗ[R] B) (a : A) (r : R) :
    f (algebraMap R A r * a) = algebraMap R B r * f a := by
  rw [← Algebra.smul_def, ← Algebra.smul_def, map_smul]","

/-- An alternate statement of `LinearMap.map_smul` for when `algebraMap` is more convenient to
work with than `•`. -/
theorem map_algebraMap_mul (f : A →ₗ[R] B) (a : A) (r : R) :
    f (algebraMap R A r * a) = algebraMap R B r * f a  := by
  rw [← Algebra.smul_def, ← Algebra.smul_def, map_smul]
",58.83977270126343
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :
    f (a * algebraMap R A r) = f a * algebraMap R B r ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,False,"unexpected token 'theorem'; expected '{' or tactic
	at: 
  theorem 
unsolved goals
R : Type u_1
A : Type u_2
B : Type u_3
inst✝⁴ : CommSemiring R
inst✝³ : Semiring A
inst✝² : Semiring B
inst✝¹ : Algebra R A
inst✝ : Algebra R B
f : A →ₗ[R] B
a : A
r : R
⊢ f (a * (algebraMap R A) r) = f a * (algebraMap R B) r
	at:     f (a * algebraMap R A r) = f a * algebraMap R B r  := by
'LinearMap.map_mul_algebraMap' has already been declared
	at:   theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :",,,"theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :
    f (a * algebraMap R A r) = f a * algebraMap R B r := by
  rw [← Algebra.commutes, ← Algebra.commutes, map_algebraMap_mul]","

theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :
    f (a * algebraMap R A r) = f a * algebraMap R B r  := by
  theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :
      f (a * algebraMap R A r) = f a * algebraMap R B r := by
    rw [← Algebra.commutes r a, map_algebraMap_mul]
    exact Algebra.commutes r (f a)
",7.0582191944122314
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :
    f (a * algebraMap R A r) = f a * algebraMap R B r ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,False,"tactic 'introN' failed, insufficient number of binders
R : Type u_1
A : Type u_2
B : Type u_3
inst✝⁴ : CommSemiring R
inst✝³ : Semiring A
inst✝² : Semiring B
inst✝¹ : Algebra R A
inst✝ : Algebra R B
f : A →ₗ[R] B
a : A
r : R
⊢ f (a * (algebraMap R A) r) = f a * (algebraMap R B) r
	at:   intro f a r",,,"theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :
    f (a * algebraMap R A r) = f a * algebraMap R B r := by
  rw [← Algebra.commutes, ← Algebra.commutes, map_algebraMap_mul]","

theorem map_mul_algebraMap (f : A →ₗ[R] B) (a : A) (r : R) :
    f (a * algebraMap R A r) = f a * algebraMap R B r  := by
  intro f a r
  rw [← Algebra.commutes, ← Algebra.commutes, map_algebraMap_mul]
",40.054715156555176
mathlib,Mathlib/Algebra/Algebra/Basic.lean,instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R) ,prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.6687500000000001,False,"unexpected token 'instance'; expected '{' or tactic
	at: 
  instance 
unsolved goals
R : Type u_1
inst✝ : Semiring R
⊢ Subsingleton (Algebra ℕ R)
	at: instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R)  := by
'nat_algebra_subsingleton' has already been declared
	at:   instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R) :=",,,"instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R) :=
  ⟨fun P Q => by ext; simp⟩","

instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R)  := by
  instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R) :=
    ⟨fun P Q =>
      by ext
      simp⟩
",6.8266401290893555
mathlib,Mathlib/Algebra/Algebra/Basic.lean,instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R) ,best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.6687500000000001,False,"tactic 'introN' failed, insufficient number of binders
R : Type u_1
inst✝ : Semiring R
⊢ Subsingleton (Algebra ℕ R)
	at:   intro P Q",,,"instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R) :=
  ⟨fun P Q => by ext; simp⟩","

instance nat_algebra_subsingleton : Subsingleton (Algebra ℕ R)  := by
  intro P Q
  ext
  simp
",35.260627031326294
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]
    [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A) ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,False,"unexpected token 'theorem'; expected '{' or tactic
	at: 
  theorem 
unsolved goals
R : Type u_1
A : Type u_2
inst✝⁴ : CommRing R
inst✝³ : Ring A
inst✝² : Nontrivial A
inst✝¹ : Algebra R A
inst✝ : NoZeroSMulDivisors R A
⊢ Function.Injective ⇑(algebraMap R A)
	at:     [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A)  := by
'NoZeroSMulDivisors.algebraMap_injective' has already been declared
	at:   theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A] [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A) := by",,,"theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]
    [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A) := by
  simpa only [algebraMap_eq_smul_one'] using smul_left_injective R one_ne_zero","

theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]
    [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A)  := by
  theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A] [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A) := by
    intros x y h
    have : algebraMap R A x = x • 1 := algebraMap_eq_smul_one' x
    have : algebraMap R A y = y • 1 := algebraMap_eq_smul_one' y
    rw [this, this] at h
    exact smul_left_injective R one_ne_zero h
",9.290261030197144
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]
    [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A) ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,False,"unexpected token 'theorem'; expected '{' or tactic
	at: 
  theorem 
unsolved goals
R : Type u_1
A : Type u_2
inst✝⁴ : CommRing R
inst✝³ : Ring A
inst✝² : Nontrivial A
inst✝¹ : Algebra R A
inst✝ : NoZeroSMulDivisors R A
⊢ Function.Injective ⇑(algebraMap R A)
	at:     [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A)  := by
'NoZeroSMulDivisors.algebraMap_injective' has already been declared
	at:   theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]",,,"theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]
    [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A) := by
  simpa only [algebraMap_eq_smul_one'] using smul_left_injective R one_ne_zero","

theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]
    [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A)  := by
  theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]
      [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A) := by
    intro r₁ r₂ h
    simp only [algebraMap_eq_smul_one'] at h
    exact smul_left_injective R one_ne_zero h
",45.040287017822266
mathlib,Mathlib/Algebra/Algebra/Basic.lean,theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m ,prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,False,"unexpected token 'theorem'; expected '{' or tactic
	at: 
  theorem 
unsolved goals
R : Type u_1
inst✝¹⁰ : CommSemiring R
A : Type u_2
inst✝⁹ : Semiring A
inst✝⁸ : Algebra R A
M : Type u_3
inst✝⁷ : AddCommMonoid M
inst✝⁶ : Module A M
inst✝⁵ : Module R M
inst✝⁴ : IsScalarTower R A M
N : Type u_4
inst✝³ : AddCommMonoid N
inst✝² : Module A N
inst✝¹ : Module R N
inst✝ : IsScalarTower R A N
r : R
m : M
⊢ r • m = (algebraMap R A) r • m
	at: theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m  := by
'algebra_compatible_smul' has already been declared
	at:   theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m := by",,,"theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m := by
  rw [← one_smul A m, ← smul_assoc, Algebra.smul_def, mul_one, one_smul]","

theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m  := by
  theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m := by
    rw [← one_smul A m, ← smul_assoc]
    rw [Algebra.smul_def, mul_one, one_smul]
",7.449172258377075
mathlib,Mathlib/Algebra/Algebra/Basic.lean,theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m ,best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,True,,0.5562380952380952,-0.3338465925292274,"theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m := by
  rw [← one_smul A m, ← smul_assoc, Algebra.smul_def, mul_one, one_smul]","

theorem algebra_compatible_smul (r : R) (m : M) : r • m = (algebraMap R A) r • m  := by
  rw [← one_smul A m]
  rw [← smul_assoc]
  rw [Algebra.smul_def]
  rw [mul_one]
  rw [one_smul]
",51.366543769836426
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem NoZeroSMulDivisors.trans (R A M : Type*) [CommRing R] [Ring A] [IsDomain A] [Algebra R A]
    [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A]
    [NoZeroSMulDivisors A M] : NoZeroSMulDivisors R M ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.43328804347826094,False,"unknown tactic
	at:   cases smul_eq_zero.mp h with H H",,,"theorem NoZeroSMulDivisors.trans (R A M : Type*) [CommRing R] [Ring A] [IsDomain A] [Algebra R A]
    [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A]
    [NoZeroSMulDivisors A M] : NoZeroSMulDivisors R M := by
  refine ⟨fun {r m} h => ?_⟩
  rw [algebra_compatible_smul A r m] at h
  cases' smul_eq_zero.1 h with H H
  · have : Function.Injective (algebraMap R A) :=
      NoZeroSMulDivisors.iff_algebraMap_injective.1 inferInstance
    left
    exact (injective_iff_map_eq_zero _).1 this _ H
  · right
    exact H","

theorem NoZeroSMulDivisors.trans (R A M : Type*) [CommRing R] [Ring A] [IsDomain A] [Algebra R A]
    [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A]
    [NoZeroSMulDivisors A M] : NoZeroSMulDivisors R M  := by
  intro r m h
  rw [algebra_compatible_smul A r m] at h
  cases smul_eq_zero.mp h with H H
  case inl =>
    have inj : Function.Injective (algebraMap R A) := NoZeroSMulDivisors.iff_algebraMap_injective.mp inferInstance
    left
    exact (injective_iff_map_eq_zero _).mp inj _ H
  case inr =>
    right
    exact H
",9.260233163833618
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"theorem NoZeroSMulDivisors.trans (R A M : Type*) [CommRing R] [Ring A] [IsDomain A] [Algebra R A]
    [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A]
    [NoZeroSMulDivisors A M] : NoZeroSMulDivisors R M ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.43328804347826094,False,"unknown tactic
	at:   cases smul_eq_zero.mp h with H1 H2",,,"theorem NoZeroSMulDivisors.trans (R A M : Type*) [CommRing R] [Ring A] [IsDomain A] [Algebra R A]
    [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A]
    [NoZeroSMulDivisors A M] : NoZeroSMulDivisors R M := by
  refine ⟨fun {r m} h => ?_⟩
  rw [algebra_compatible_smul A r m] at h
  cases' smul_eq_zero.1 h with H H
  · have : Function.Injective (algebraMap R A) :=
      NoZeroSMulDivisors.iff_algebraMap_injective.1 inferInstance
    left
    exact (injective_iff_map_eq_zero _).1 this _ H
  · right
    exact H","

theorem NoZeroSMulDivisors.trans (R A M : Type*) [CommRing R] [Ring A] [IsDomain A] [Algebra R A]
    [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A]
    [NoZeroSMulDivisors A M] : NoZeroSMulDivisors R M  := by
  intro r m h
  rw [algebra_compatible_smul A r m] at h
  cases smul_eq_zero.mp h with H1 H2
  case inl {
    have inj : Function.Injective (algebraMap R A) := NoZeroSMulDivisors.iff_algebraMap_injective.1 inferInstance
    left
    exact (injective_iff_map_eq_zero _).mp inj _ H1
  }
  case inr {
    right
    exact H2
  }
",55.341965198516846
mathlib,Mathlib/Algebra/Algebra/Basic.lean,instance (priority ,prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,False,"unexpected token 'instance'; expected term
	at: 

instance 
unexpected token 'by'; expected prio
	at: instance (priority  := by",,,"instance (priority := 120) IsScalarTower.to_smulCommClass : SMulCommClass R A M :=
  ⟨fun r a m => by
    rw [algebra_compatible_smul A r (a • m), smul_smul, Algebra.commutes, mul_smul, ←
      algebra_compatible_smul]⟩","

instance (priority  := by
  ⟨fun r a m => by
  rw [algebra_compatible_smul A r (a • m)]
  rw [smul_smul]
  rw [Algebra.commutes]
  rw [mul_smul]
  rw [← algebra_compatible_smul]⟩
",8.654089212417603
mathlib,Mathlib/Algebra/Algebra/Basic.lean,instance (priority ,best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,False,"unexpected token 'instance'; expected term
	at: 

instance 
unexpected token 'by'; expected prio
	at: instance (priority  := by",,,"instance (priority := 120) IsScalarTower.to_smulCommClass : SMulCommClass R A M :=
  ⟨fun r a m => by
    rw [algebra_compatible_smul A r (a • m), smul_smul, Algebra.commutes, mul_smul, ←
      algebra_compatible_smul]⟩","

instance (priority  := by
  constructor
  intro r a m
  rw [algebra_compatible_smul A r (a • m)]
  rw [smul_smul]
  rw [Algebra.commutes]
  rw [mul_smul]
  rw [← algebra_compatible_smul]
",47.99991488456726
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
invertible when `algebraMap R A r` is. -/
abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}
    (h : Invertible (algebraMap R A r)) : Invertible (algebraMap R B r) where
  invOf ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.7525000000000001,False,"expected '{' or indented tactic sequence
	at:   /-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
unsolved goals
R : Type u_1
A : Type u_2
B : Type u_3
inst✝⁴ : CommSemiring R
inst✝³ : Semiring A
inst✝² : Semiring B
inst✝¹ : Algebra R A
inst✝ : Algebra R B
f : A →ₗ[R] B
hf : f 1 = 1
r : R
h : Invertible ((algebraMap R A) r)
⊢ B
	at:   invOf  := by
'Invertible.algebraMapOfInvertibleAlgebraMap' has already been declared
	at:   abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}",,,"/-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
invertible when `algebraMap R A r` is. -/
abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}
    (h : Invertible (algebraMap R A r)) : Invertible (algebraMap R B r) where
  invOf := f ⅟(algebraMap R A r)
  invOf_mul_self := by rw [← Algebra.commutes, ← Algebra.smul_def, ← map_smul, Algebra.smul_def,
    mul_invOf_self, hf]
  mul_invOf_self := by rw [← Algebra.smul_def, ← map_smul, Algebra.smul_def, mul_invOf_self, hf]","

/-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
invertible when `algebraMap R A r` is. -/
abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}
    (h : Invertible (algebraMap R A r)) : Invertible (algebraMap R B r) where
  invOf  := by
  /-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
  invertible when `algebraMap R A r` is. -/
  abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}
  (h : Invertible (algebraMap R A r)) : Invertible (algebraMap R B r) where
    invOf := f (⅟ (algebraMap R A r))
    invOf_mul_self := by
      rw [← Algebra.commutes, ← Algebra.smul_def, ← map_smul, Algebra.smul_def]
      rw [mul_invOf_self, hf]
    mul_invOf_self := by
      rw [← Algebra.smul_def, ← map_smul, Algebra.smul_def]
      rw [mul_invOf_self, hf]
",12.757874965667725
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
invertible when `algebraMap R A r` is. -/
abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}
    (h : Invertible (algebraMap R A r)) : Invertible (algebraMap R B r) where
  invOf ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.7525000000000001,False,"expected '{' or indented tactic sequence
	at:   /-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
unsolved goals
R : Type u_1
A : Type u_2
B : Type u_3
inst✝⁴ : CommSemiring R
inst✝³ : Semiring A
inst✝² : Semiring B
inst✝¹ : Algebra R A
inst✝ : Algebra R B
f : A →ₗ[R] B
hf : f 1 = 1
r : R
h : Invertible ((algebraMap R A) r)
⊢ B
	at:   invOf  := by
'Invertible.algebraMapOfInvertibleAlgebraMap' has already been declared
	at:   abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}",,,"/-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
invertible when `algebraMap R A r` is. -/
abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}
    (h : Invertible (algebraMap R A r)) : Invertible (algebraMap R B r) where
  invOf := f ⅟(algebraMap R A r)
  invOf_mul_self := by rw [← Algebra.commutes, ← Algebra.smul_def, ← map_smul, Algebra.smul_def,
    mul_invOf_self, hf]
  mul_invOf_self := by rw [← Algebra.smul_def, ← map_smul, Algebra.smul_def, mul_invOf_self, hf]","

/-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
invertible when `algebraMap R A r` is. -/
abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}
    (h : Invertible (algebraMap R A r)) : Invertible (algebraMap R B r) where
  invOf  := by
  /-- If there is a linear map `f : A →ₗ[R] B` that preserves `1`, then `algebraMap R B r` is
  invertible when `algebraMap R A r` is. -/
  abbrev Invertible.algebraMapOfInvertibleAlgebraMap (f : A →ₗ[R] B) (hf : f 1 = 1) {r : R}
  (h : Invertible (algebraMap R A r)) : Invertible (algebraMap R B r) where
    invOf := f (⅟(algebraMap R A r))
    invOf_mul_self := by
      rw [← Algebra.commutes]
      rw [← Algebra.smul_def]
      rw [← map_smul]
      rw [Algebra.smul_def]
      rw [mul_invOf_self]
      rw [hf]
    mul_invOf_self := by
      rw [← Algebra.smul_def]
      rw [← map_smul]
      rw [Algebra.smul_def]
      rw [mul_invOf_self]
      rw [hf]
",68.60748529434204
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- If `E` is an `F`-algebra, and there exists an injective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also injective. -/
theorem injective_algebraMap_of_linearMap (hb : Function.Injective b) :
    Function.Injective (algebraMap F E) ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,True,,0.41567460317460314,-0.5021861039825113,"/-- If `E` is an `F`-algebra, and there exists an injective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also injective. -/
theorem injective_algebraMap_of_linearMap (hb : Function.Injective b) :
    Function.Injective (algebraMap F E) := fun x y e ↦ hb <| by
  rw [← mul_one x, ← mul_one y, ← smul_eq_mul, ← smul_eq_mul,
    map_smul, map_smul, Algebra.smul_def, Algebra.smul_def, e]","

/-- If `E` is an `F`-algebra, and there exists an injective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also injective. -/
theorem injective_algebraMap_of_linearMap (hb : Function.Injective b) :
    Function.Injective (algebraMap F E)  := by
  intro x y e
  apply hb
  rw [← mul_one x, ← mul_one y]
  rw [← smul_eq_mul, ← smul_eq_mul]
  rw [map_smul, map_smul]
  rw [Algebra.smul_def, Algebra.smul_def, e]
",9.715489149093628
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- If `E` is an `F`-algebra, and there exists an injective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also injective. -/
theorem injective_algebraMap_of_linearMap (hb : Function.Injective b) :
    Function.Injective (algebraMap F E) ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.8350000000000001,False,"type mismatch
  h
has type
  (algebraMap F E) x = (algebraMap F E) y : Prop
but is expected to have type
  (algebraMap F E) x * b 1 = (algebraMap F E) y * b 1 : Prop
	at:   exact h",,,"/-- If `E` is an `F`-algebra, and there exists an injective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also injective. -/
theorem injective_algebraMap_of_linearMap (hb : Function.Injective b) :
    Function.Injective (algebraMap F E) := fun x y e ↦ hb <| by
  rw [← mul_one x, ← mul_one y, ← smul_eq_mul, ← smul_eq_mul,
    map_smul, map_smul, Algebra.smul_def, Algebra.smul_def, e]","

/-- If `E` is an `F`-algebra, and there exists an injective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also injective. -/
theorem injective_algebraMap_of_linearMap (hb : Function.Injective b) :
    Function.Injective (algebraMap F E)  := by
  intro x y h
  apply hb
  rw [← mul_one x, ← mul_one y, ← smul_eq_mul, ← smul_eq_mul]
  rw [map_smul, map_smul, Algebra.smul_def, Algebra.smul_def]
  exact h
",61.8246169090271
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- If `E` is an `F`-algebra, and there exists a surjective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also surjective. -/
theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :
    Function.Surjective (algebraMap F E) ",prompt_flat,5,READABILITY,gpt-4o,True,False,False,4,True,,0.2825701754385965,False,"unexpected token 'theorem'; expected '{' or tactic
	at: 
  theorem 
unsolved goals
F : Type u_1
E : Type u_2
inst✝² : CommSemiring F
inst✝¹ : Semiring E
inst✝ : Algebra F E
b : F →ₗ[F] E
hb : Function.Surjective ⇑b
⊢ Function.Surjective ⇑(algebraMap F E)
	at:     Function.Surjective (algebraMap F E)  := by
'surjective_algebraMap_of_linearMap' has already been declared
	at:   theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :",,,"/-- If `E` is an `F`-algebra, and there exists a surjective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also surjective. -/
theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :
    Function.Surjective (algebraMap F E) := fun x ↦ by
  obtain ⟨x, rfl⟩ := hb x
  obtain ⟨y, hy⟩ := hb (b 1 * b 1)
  refine ⟨x * y, ?_⟩
  obtain ⟨z, hz⟩ := hb 1
  apply_fun (x • z • ·) at hy
  rwa [← map_smul, smul_eq_mul, mul_comm, ← smul_mul_assoc, ← map_smul _ z, smul_eq_mul, mul_one,
    ← smul_eq_mul, map_smul, hz, one_mul, ← map_smul, smul_eq_mul, mul_one, smul_smul,
    ← Algebra.algebraMap_eq_smul_one] at hy","

/-- If `E` is an `F`-algebra, and there exists a surjective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also surjective. -/
theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :
    Function.Surjective (algebraMap F E)  := by
  theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :
      Function.Surjective (algebraMap F E) := fun x ↦ by
    obtain ⟨x, rfl⟩ := hb x
    obtain ⟨y, hy⟩ := hb (b 1 * b 1)
    refine ⟨x * y, ?_⟩
    obtain ⟨z, hz⟩ := hb 1
    apply_fun (x • z • ·) at hy
    rw [← map_smul, smul_eq_mul, mul_comm, ← smul_mul_assoc,
        ← map_smul _ z, smul_eq_mul, mul_one, ← smul_eq_mul,
        map_smul, hz, one_mul, ← map_smul, smul_eq_mul,
        mul_one, smul_smul, ← Algebra.algebraMap_eq_smul_one] at hy
    exact hy
",12.177097082138062
mathlib,Mathlib/Algebra/Algebra/Basic.lean,"/-- If `E` is an `F`-algebra, and there exists a surjective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also surjective. -/
theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :
    Function.Surjective (algebraMap F E) ",best_of_n,5,READABILITY,gpt-4o,True,False,False,4,True,,0.2825701754385965,False,"unexpected token '/--'; expected '{' or tactic
	at: 
  /-- 
unsolved goals
F : Type u_1
E : Type u_2
inst✝² : CommSemiring F
inst✝¹ : Semiring E
inst✝ : Algebra F E
b : F →ₗ[F] E
hb : Function.Surjective ⇑b
⊢ Function.Surjective ⇑(algebraMap F E)
	at:     Function.Surjective (algebraMap F E)  := by
'surjective_algebraMap_of_linearMap' has already been declared
	at:   theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :",,,"/-- If `E` is an `F`-algebra, and there exists a surjective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also surjective. -/
theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :
    Function.Surjective (algebraMap F E) := fun x ↦ by
  obtain ⟨x, rfl⟩ := hb x
  obtain ⟨y, hy⟩ := hb (b 1 * b 1)
  refine ⟨x * y, ?_⟩
  obtain ⟨z, hz⟩ := hb 1
  apply_fun (x • z • ·) at hy
  rwa [← map_smul, smul_eq_mul, mul_comm, ← smul_mul_assoc, ← map_smul _ z, smul_eq_mul, mul_one,
    ← smul_eq_mul, map_smul, hz, one_mul, ← map_smul, smul_eq_mul, mul_one, smul_smul,
    ← Algebra.algebraMap_eq_smul_one] at hy","

/-- If `E` is an `F`-algebra, and there exists a surjective `F`-linear map from `F` to `E`,
then the algebra map from `F` to `E` is also surjective. -/
theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :
    Function.Surjective (algebraMap F E)  := by
  /-- If `E` is an `F`-algebra, and there exists a surjective `F`-linear map from `F` to `E`,
  then the algebra map from `F` to `E` is also surjective. -/
  theorem surjective_algebraMap_of_linearMap (hb : Function.Surjective b) :
      Function.Surjective (algebraMap F E) :=
    fun x ↦ by
      obtain ⟨x, rfl⟩ := hb x
      obtain ⟨y, hy⟩ := hb (b 1 * b 1)
      refine ⟨x * y, ?_⟩
      obtain ⟨z, hz⟩ := hb 1
      apply_fun (x • z • ·) at hy
      rwa [← map_smul, smul_eq_mul, mul_comm, ← smul_mul_assoc, ← map_smul _ z, smul_eq_mul,
           mul_one, ← smul_eq_mul, map_smul, hz, one_mul, ← map_smul, smul_eq_mul, mul_one,
           smul_smul, ← Algebra.algebraMap_eq_smul_one] at hy
",66.75195002555847
