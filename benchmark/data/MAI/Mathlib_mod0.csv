repo,file,decl,method,n,metric,model,annotation,syntax_search,mathlib_search,examples,og_correct,og_errors,og_score,new_correct,new_errors,new_score,delta,og_raw,new_raw,time
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,"/-- If `f(p(t) = g(q(t))` for two paths `p` and `q`, then the induced path homotopy classes
`f(p)` and `g(p)` are the same as well, despite having a priori different types -/
theorem heq_path_of_eq_image : HEq ((œÄ‚Çò f).map ‚ü¶p‚üß) ((œÄ‚Çò g).map ‚ü¶q‚üß) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,1.0,True,,1.0,0.0,"
/-- If `f(p(t) = g(q(t))` for two paths `p` and `q`, then the induced path homotopy classes
`f(p)` and `g(p)` are the same as well, despite having a priori different types -/
theorem heq_path_of_eq_image : HEq ((œÄ‚Çò f).map ‚ü¶p‚üß) ((œÄ‚Çò g).map ‚ü¶q‚üß)  := by
  simp only [map_eq, ‚Üê Path.Homotopic.map_lift]; apply Path.Homotopic.hpath_hext; exact hfg","
/-- If `f(p(t) = g(q(t))` for two paths `p` and `q`, then the induced path homotopy classes
`f(p)` and `g(p)` are the same as well, despite having a priori different types -/
theorem heq_path_of_eq_image : HEq ((œÄ‚Çò f).map ‚ü¶p‚üß) ((œÄ‚Çò g).map ‚ü¶q‚üß)  := by
  simp only [map_eq, ‚Üê Path.Homotopic.map_lift]; apply Path.Homotopic.hpath_hext; exact hfg",153.2454571723938
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,private theorem start_path : f x‚ÇÄ = g x‚ÇÇ ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,1.0,True,,1.0,0.0,"
private theorem start_path : f x‚ÇÄ = g x‚ÇÇ  := by
private theorem start_path : f x‚ÇÄ = g x‚ÇÇ := by convert hfg 0 <;> simp only [Path.source]","
private theorem start_path : f x‚ÇÄ = g x‚ÇÇ  := by
private theorem start_path : f x‚ÇÄ = g x‚ÇÇ := by convert hfg 0 <;> simp only [Path.source]",153.87794518470764
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,private theorem end_path : f x‚ÇÅ = g x‚ÇÉ ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,1.0,True,,1.75,0.75,"
private theorem end_path : f x‚ÇÅ = g x‚ÇÉ  := by
private theorem end_path : f x‚ÇÅ = g x‚ÇÉ := by convert hfg 1 <;> simp only [Path.target]","
private theorem end_path : f x‚ÇÅ = g x‚ÇÉ    := by
  have h_fg_start : f x‚ÇÄ = g x‚ÇÇ := by convert hfg 0 <;> simp only [Path.source]
  have h_fg_end : f x‚ÇÅ = g x‚ÇÉ := by convert hfg 1 <;> simp only [Path.target]
  exact h_fg_end",175.8216152191162
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,"theorem eq_path_of_eq_image :
    (œÄ‚Çò f).map ‚ü¶p‚üß = hcast (start_path hfg) ‚â´ (œÄ‚Çò g).map ‚ü¶q‚üß ‚â´ hcast (end_path hfg).symm ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,0.0,True,,1.625,,"
theorem eq_path_of_eq_image :
    (œÄ‚Çò f).map ‚ü¶p‚üß = hcast (start_path hfg) ‚â´ (œÄ‚Çò g).map ‚ü¶q‚üß ‚â´ hcast (end_path hfg).symm  := by
  rw [Functor.conj_eqToHom_iff_heq
    ((œÄ‚Çò f).map ‚ü¶p‚üß) ((œÄ‚Çò g).map ‚ü¶q‚üß)
    (FundamentalGroupoid.ext _ _ <| start_path hfg)
    (FundamentalGroupoid.ext _ _ <| end_path hfg)]
  exact heq_path_of_eq_image hfg","
theorem eq_path_of_eq_image :
    (œÄ‚Çò f).map ‚ü¶p‚üß = hcast (start_path hfg) ‚â´ (œÄ‚Çò g).map ‚ü¶q‚üß ‚â´ hcast (end_path hfg).symm   := by
  rw [Functor.conj_eqToHom_iff_heq ((œÄ‚Çò f).map ‚ü¶p‚üß) ((œÄ‚Çò g).map ‚ü¶q‚üß) (FundamentalGroupoid.ext _ _ <| start_path hfg) (FundamentalGroupoid.ext _ _ <| end_path hfg)]
  have h1 : ‚àÄ t, f (p t) = g (q t) := hfg
  have h2 : f x‚ÇÄ = g x‚ÇÇ := by convert h1 0 <;> simp only [Path.source]
  have h3 : f x‚ÇÅ = g x‚ÇÉ := by convert h1 1 <;> simp only [Path.target]
  have h4 : HEq ((œÄ‚Çò f).map ‚ü¶p‚üß) ((œÄ‚Çò g).map ‚ü¶q‚üß) := by simp only [map_eq, ‚Üê Path.Homotopic.map_lift]; apply Path.Homotopic.hpath_hext; exact h1
  exact h4",202.3150293827057
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,"/-- Proof that `f(p) = H(0 ‚ü∂ 0, p)`, with the appropriate casts -/
theorem apply_zero_path : (œÄ‚Çò f).map p = hcast (H.apply_zero x‚ÇÄ).symm ‚â´
    (œÄ‚Çò H.uliftMap).map (prodToProdTopI (ùüô (@fromTop (TopCat.of _) (ULift.up 0))) p) ‚â´
    hcast (H.apply_zero x‚ÇÅ) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,1.0,True,,1.0,0.0,"
/-- Proof that `f(p) = H(0 ‚ü∂ 0, p)`, with the appropriate casts -/
theorem apply_zero_path : (œÄ‚Çò f).map p = hcast (H.apply_zero x‚ÇÄ).symm ‚â´
    (œÄ‚Çò H.uliftMap).map (prodToProdTopI (ùüô (@fromTop (TopCat.of _) (ULift.up 0))) p) ‚â´
    hcast (H.apply_zero x‚ÇÅ)  := by
    apply @eq_path_of_eq_image _ _ _ _ H.uliftMap _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')
    -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644
    erw [Path.prod_coe]; simp_rw [ulift_apply]; simp","
/-- Proof that `f(p) = H(0 ‚ü∂ 0, p)`, with the appropriate casts -/
theorem apply_zero_path : (œÄ‚Çò f).map p = hcast (H.apply_zero x‚ÇÄ).symm ‚â´
    (œÄ‚Çò H.uliftMap).map (prodToProdTopI (ùüô (@fromTop (TopCat.of _) (ULift.up 0))) p) ‚â´
    hcast (H.apply_zero x‚ÇÅ)  := by
    apply @eq_path_of_eq_image _ _ _ _ H.uliftMap _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')
    -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644
    erw [Path.prod_coe]; simp_rw [ulift_apply]; simp",191.7021288871765
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,"/-- Proof that `g(p) = H(1 ‚ü∂ 1, p)`, with the appropriate casts -/
theorem apply_one_path : (œÄ‚Çò g).map p = hcast (H.apply_one x‚ÇÄ).symm ‚â´
    (œÄ‚Çò H.uliftMap).map (prodToProdTopI (ùüô (@fromTop (TopCat.of _) (ULift.up 1))) p) ‚â´
    hcast (H.apply_one x‚ÇÅ) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,1.0,True,,1.0,0.0,"
/-- Proof that `g(p) = H(1 ‚ü∂ 1, p)`, with the appropriate casts -/
theorem apply_one_path : (œÄ‚Çò g).map p = hcast (H.apply_one x‚ÇÄ).symm ‚â´
    (œÄ‚Çò H.uliftMap).map (prodToProdTopI (ùüô (@fromTop (TopCat.of _) (ULift.up 1))) p) ‚â´
    hcast (H.apply_one x‚ÇÅ)  := by
    apply @eq_path_of_eq_image _ _ _ _ H.uliftMap _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')
    -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644
    erw [Path.prod_coe]; simp_rw [ulift_apply]; simp","
/-- Proof that `g(p) = H(1 ‚ü∂ 1, p)`, with the appropriate casts -/
theorem apply_one_path : (œÄ‚Çò g).map p = hcast (H.apply_one x‚ÇÄ).symm ‚â´
    (œÄ‚Çò H.uliftMap).map (prodToProdTopI (ùüô (@fromTop (TopCat.of _) (ULift.up 1))) p) ‚â´
    hcast (H.apply_one x‚ÇÅ)  := by
    apply @eq_path_of_eq_image _ _ _ _ H.uliftMap _ _ _ _ _ ((Path.refl (ULift.up _)).prod p')
    -- This used to be `rw`, but we need `erw` after leanprover/lean4#2644
    erw [Path.prod_coe]; simp_rw [ulift_apply]; simp",1075.6325750350952
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,"/-- Proof that `H.evalAt x = H(0 ‚ü∂ 1, x ‚ü∂ x)`, with the appropriate casts -/
theorem evalAt_eq (x : X) : ‚ü¶H.evalAt x‚üß = hcast (H.apply_zero x).symm ‚â´
    (œÄ‚Çò H.uliftMap).map (prodToProdTopI uhpath01 (ùüô (fromTop x))) ‚â´
      hcast (H.apply_one x).symm.symm ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,1.0,True,,1.0,0.0,"
/-- Proof that `H.evalAt x = H(0 ‚ü∂ 1, x ‚ü∂ x)`, with the appropriate casts -/
theorem evalAt_eq (x : X) : ‚ü¶H.evalAt x‚üß = hcast (H.apply_zero x).symm ‚â´
    (œÄ‚Çò H.uliftMap).map (prodToProdTopI uhpath01 (ùüô (fromTop x))) ‚â´
      hcast (H.apply_one x).symm.symm  := by
  dsimp only [prodToProdTopI, uhpath01, hcast]
  refine (@Functor.conj_eqToHom_iff_heq (œÄ‚Çì Y) _ _ _ _ _ _ _ _
    (FundamentalGroupoid.ext _ _ <| H.apply_one x).symm).mpr ?_
  simp only [id_eq_path_refl, prodToProdTop_map, Path.Homotopic.prod_lift, map_eq, ‚Üê
    Path.Homotopic.map_lift]
  apply Path.Homotopic.hpath_hext; intro; rfl","
/-- Proof that `H.evalAt x = H(0 ‚ü∂ 1, x ‚ü∂ x)`, with the appropriate casts -/
theorem evalAt_eq (x : X) : ‚ü¶H.evalAt x‚üß = hcast (H.apply_zero x).symm ‚â´
    (œÄ‚Çò H.uliftMap).map (prodToProdTopI uhpath01 (ùüô (fromTop x))) ‚â´
      hcast (H.apply_one x).symm.symm  := by
  dsimp only [prodToProdTopI, uhpath01, hcast]
  refine (@Functor.conj_eqToHom_iff_heq (œÄ‚Çì Y) _ _ _ _ _ _ _ _
    (FundamentalGroupoid.ext _ _ <| H.apply_one x).symm).mpr ?_
  simp only [id_eq_path_refl, prodToProdTop_map, Path.Homotopic.prod_lift, map_eq, ‚Üê
    Path.Homotopic.map_lift]
  apply Path.Homotopic.hpath_hext; intro; rfl",220.06996703147888
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,"theorem eq_diag_path : (œÄ‚Çò f).map p ‚â´ ‚ü¶H.evalAt x‚ÇÅ‚üß = H.diagonalPath' p ‚àß
    (‚ü¶H.evalAt x‚ÇÄ‚üß ‚â´ (œÄ‚Çò g).map p : fromTop (f x‚ÇÄ) ‚ü∂ fromTop (g x‚ÇÅ)) = H.diagonalPath' p ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,1.7142857142857142,True,,1.7142857142857142,0.0,"
theorem eq_diag_path : (œÄ‚Çò f).map p ‚â´ ‚ü¶H.evalAt x‚ÇÅ‚üß = H.diagonalPath' p ‚àß
    (‚ü¶H.evalAt x‚ÇÄ‚üß ‚â´ (œÄ‚Çò g).map p : fromTop (f x‚ÇÄ) ‚ü∂ fromTop (g x‚ÇÅ)) = H.diagonalPath' p  := by
  rw [H.apply_zero_path, H.apply_one_path, H.evalAt_eq]
  erw [H.evalAt_eq] -- Porting note: `rw` didn't work, so using `erw`
  dsimp only [prodToProdTopI]
  constructor
  ¬∑ slice_lhs 2 4 => rw [eqToHom_trans, eqToHom_refl] -- Porting note: this ‚Üì `simp` didn't do this
    slice_lhs 2 4 => simp [‚Üê CategoryTheory.Functor.map_comp]
    rfl
  ¬∑ slice_lhs 2 4 => rw [eqToHom_trans, eqToHom_refl] -- Porting note: this ‚Üì `simp` didn't do this
    slice_lhs 2 4 => simp [‚Üê CategoryTheory.Functor.map_comp]
    rfl","
theorem eq_diag_path : (œÄ‚Çò f).map p ‚â´ ‚ü¶H.evalAt x‚ÇÅ‚üß = H.diagonalPath' p ‚àß
    (‚ü¶H.evalAt x‚ÇÄ‚üß ‚â´ (œÄ‚Çò g).map p : fromTop (f x‚ÇÄ) ‚ü∂ fromTop (g x‚ÇÅ)) = H.diagonalPath' p  := by
  rw [H.apply_zero_path, H.apply_one_path, H.evalAt_eq]
  erw [H.evalAt_eq] -- Porting note: `rw` didn't work, so using `erw`
  dsimp only [prodToProdTopI]
  constructor
  ¬∑ slice_lhs 2 4 => rw [eqToHom_trans, eqToHom_refl] -- Porting note: this ‚Üì `simp` didn't do this
    slice_lhs 2 4 => simp [‚Üê CategoryTheory.Functor.map_comp]
    rfl
  ¬∑ slice_lhs 2 4 => rw [eqToHom_trans, eqToHom_refl] -- Porting note: this ‚Üì `simp` didn't do this
    slice_lhs 2 4 => simp [‚Üê CategoryTheory.Functor.map_comp]
    rfl",264.384158372879
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,"/-- Given a homotopy H : f ‚àº g, we have an associated natural isomorphism between the induced
functors `f` and `g` -/
-- Porting note: couldn't use category arrow `\hom` in statement, needed to expand
def homotopicMapsNatIso : @Quiver.Hom _ Functor.category.toQuiver (œÄ‚Çò f) (œÄ‚Çò g) where
  app x ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,0.0,True,,0.0,,"
/-- Given a homotopy H : f ‚àº g, we have an associated natural isomorphism between the induced
functors `f` and `g` -/
-- Porting note: couldn't use category arrow `\hom` in statement, needed to expand
def homotopicMapsNatIso : @Quiver.Hom _ Functor.category.toQuiver (œÄ‚Çò f) (œÄ‚Çò g) where
  app x  := by
  naturality x y p := by erw [(H.eq_diag_path p).1, (H.eq_diag_path p).2]","
/-- Given a homotopy H : f ‚àº g, we have an associated natural isomorphism between the induced
functors `f` and `g` -/
-- Porting note: couldn't use category arrow `\hom` in statement, needed to expand
def homotopicMapsNatIso : @Quiver.Hom _ Functor.category.toQuiver (œÄ‚Çò f) (œÄ‚Çò g) where
  app x  := by
  naturality x y p := by erw [(H.eq_diag_path p).1, (H.eq_diag_path p).2]",218.0629551410675
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,instance : IsIso (homotopicMapsNatIso H) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,0.0,True,,0.0,,"
instance : IsIso (homotopicMapsNatIso H)  := by
instance : IsIso (homotopicMapsNatIso H) := by apply NatIso.isIso_of_isIso_app","
instance : IsIso (homotopicMapsNatIso H)  := by
instance : IsIso (homotopicMapsNatIso H) := by apply NatIso.isIso_of_isIso_app",221.3695101737976
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/InducedMaps.lean,"/-- Homotopy equivalent topological spaces have equivalent fundamental groupoids. -/
def equivOfHomotopyEquiv (hequiv : X ‚âÉ‚Çï Y) : œÄ‚Çì X ‚âå œÄ‚Çì Y ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,1.4,True,,1.4,0.0,"
/-- Homotopy equivalent topological spaces have equivalent fundamental groupoids. -/
def equivOfHomotopyEquiv (hequiv : X ‚âÉ‚Çï Y) : œÄ‚Çì X ‚âå œÄ‚Çì Y  := by
  apply CategoryTheory.Equivalence.mk (œÄ‚Çò hequiv.toFun : œÄ‚Çì X ‚•§ œÄ‚Çì Y)
    (œÄ‚Çò hequiv.invFun : œÄ‚Çì Y ‚•§ œÄ‚Çì X) <;>
    simp only [Grpd.hom_to_functor, Grpd.id_to_functor]
  ¬∑ convert (asIso (homotopicMapsNatIso hequiv.left_inv.some)).symm
    exacts [((œÄ).map_id X).symm, ((œÄ).map_comp _ _).symm]
  ¬∑ convert asIso (homotopicMapsNatIso hequiv.right_inv.some)
    exacts [((œÄ).map_comp _ _).symm, ((œÄ).map_id Y).symm]","
/-- Homotopy equivalent topological spaces have equivalent fundamental groupoids. -/
def equivOfHomotopyEquiv (hequiv : X ‚âÉ‚Çï Y) : œÄ‚Çì X ‚âå œÄ‚Çì Y  := by
  apply CategoryTheory.Equivalence.mk (œÄ‚Çò hequiv.toFun : œÄ‚Çì X ‚•§ œÄ‚Çì Y)
    (œÄ‚Çò hequiv.invFun : œÄ‚Çì Y ‚•§ œÄ‚Çì X) <;>
    simp only [Grpd.hom_to_functor, Grpd.id_to_functor]
  ¬∑ convert (asIso (homotopicMapsNatIso hequiv.left_inv.some)).symm
    exacts [((œÄ).map_id X).symm, ((œÄ).map_comp _ _).symm]
  ¬∑ convert asIso (homotopicMapsNatIso hequiv.right_inv.some)
    exacts [((œÄ).map_comp _ _).symm, ((œÄ).map_id Y).symm]",266.1834168434143
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/FundamentalGroup.lean,instance (X : Type u) [TopologicalSpace X] (x : X) : Group (FundamentalGroup X x) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,0.0,True,,0.0,,"
instance (X : Type u) [TopologicalSpace X] (x : X) : Group (FundamentalGroup X x)  := by
  dsimp only [FundamentalGroup]
  infer_instance","
instance (X : Type u) [TopologicalSpace X] (x : X) : Group (FundamentalGroup X x)  := by
  dsimp only [FundamentalGroup]
  infer_instance",324.06467390060425
mathlib,Mathlib/AlgebraicTopology/FundamentalGroupoid/FundamentalGroup.lean,instance (X : Type u) [TopologicalSpace X] (x : X) : Inhabited (FundamentalGroup X x) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,MODULARITY,gpt-4o,True,True,True,10,True,,0.0,True,,2.0,,"
instance (X : Type u) [TopologicalSpace X] (x : X) : Inhabited (FundamentalGroup X x)  := by
  dsimp only [FundamentalGroup]
  infer_instance","
instance (X : Type u) [TopologicalSpace X] (x : X) : Inhabited (FundamentalGroup X x)   := by
  dsimp only [FundamentalGroup]
  have instAutoInhabited : Inhabited (Aut (FundamentalGroupoid.mk x)) := by infer_instance
  exact instAutoInhabited",183.24104404449463
